==> tdd-lab.npm/lessons/00/README-00.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 0: Creating a Development Environment

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Configuration](#configuration)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will get your computer and repository ready for the subsequent lessons.

## <a name="setup"></a>Setup

1. With your browser, make sure you are logged in on Bitbucket.
1. If you are not reading this on Bitbucket, visit [this repository]().
1. Create a fork of this repository, using the &ldquo;Create fork&rdquo; action in the left sidebar of the Bitbucket window. You can temporarily expand the sidebar (&raquo;) to see the action descriptions.
1. Navigate with your browser to your fork on Bitbucket.
1. Open the &ldquo;Repository settings&rdquo; tool in the left sidebar.
1. Under &ldquo;SECURITY&rdquo;, select &ldquo;Repository permissions&rdquo;.
1. Under &ldquo;Group access&rdquo;, grant &ldquo;Read&rdquo; permission to the group `rol bitbucket user dvt`. Press the &ldquo;Add&rdquo; button to finalize this grant. (If you want non-users of Bitbucket, too, to be able to read and copy your fork, you can also check &ldquo;Enable&rdquo; under &ldquo;Public access&rdquo;.)
1. Above &ldquo;SECURITY&rdquo;, select &ldquo;Web Pages&rdquo;.
1. Enable pages for the `master` branch and the `feature/current` branch.
1. Also enable automatic pages for new branches.
1. Select &ldquo;Hooks&rdquo; under &ldquo;WORKFLOW&rdquo;. Turn off &ldquo;Yet Another Commit Checker&rdquo; if it is on.
1. Return to the main page of your fork by choosing &ldquo;Source&rdquo; under &ldquo;NAVIGATION&rdquo; in the left sidebar.
1. Decide on a directory on your computer that you will create a local copy of your fork in (for example, `~/Documents/training`). Warning: failures have been reported when any of the directory names in this path contain spaces. To prevent problems, use a path whose directory names contain no spaces, and also no `:` or `/` or `\` characters.
1. If that directory doesn&rsquo;t exist yet, create it in your bash shell (for example, `mkdir ~/Documents/training`).
1. Navigate to that directory (for example, `cd ~/Documents/training`).
1. Clone your fork. To do this:
    1. In your browser, choose the &ldquo;Clone&rdquo; action in the left sidebar.
    1. Copy the URL that appears.
    1. In your bash shell type `git clone` and finish the line by pasting what you copied. (Pasting in Git Bash has the shortcut `SHIFT`-`INSERT`.) That creates a directory within your current working directory.
1. Navigate into the local copy of your fork (`cd tdd-lab.npm`).
1. When you are in the `tdd-lab.npm` directory, your bash shell tells you which branch you are currently on. Initially, the branch is named `master`. Verify that this is true.
1. Get a list of all the branches (`git branch -a`). One of them should be `feature/current`.
1. Switch to the `feature/current` branch (`git checkout feature/current`).

## <a name="configuration"></a>Configuration

1. In your code editor, open your local repository (which the code editor may call a &ldquo;project&rdquo;). The code editor should update its content whenever the files in your repository change and whenever you switch between branches. So, the code editor should confirm that you are now on the `feature/current` branch. (In WebStorm, the branch is shown in the lower right corner, and in VS Code it is in the lower left corner.) In case the code editor gets out of sync or stops showing the branch name, one of these techniques will correct that:
   - Press `ENTER` in your bash shell and then return to the code editor.
   - Resynchronize the code editor with git. (In WebStorm, the &ldquo;Synchronize&rdquo; command is in the &ldquo;File&rdquo; menu. In VS Code it is a button on the left side of the status bar at the bottom.)
   - Close the project in your code editor and reopen it.
1. Open the `package.json` file. This file is the main configuration file for your application. It is part of the [Node Package Manager (NPM) system](https://docs.npmjs.com/) for managing software packages that applications depend on. Each branch has its own `package.json` file, reflecting the needs of that branch.
1. Add yourself to the array of `contributors`. Follow the format carefully, and be sure that your code editor does not warn you about syntax errors.
1. Change the value of `repository` so it refers to your fork, by replacing the UID with your own.
1. Save the `package.json` file.
1. In your bash shell, check your global git configuration (`git config --global --list`). If it is wrong, or if you don&rsquo;t even have one, enter statements to create the correct configuration:
   1. Your full name (`git config --global user.name 'Lastname,Firstname'`).
   1. Your email address (`git config --global user.email firstname_lastname@Utopia.com`).
   1. Then check the configuration again.

## <a name="completion"></a>Completion

1. In your bash shell, see what files you changed (`git status`).
1. Add the changes to this branch&rsquo;s index (`git add .`).
1. Commit the changed index to the local repository (`git commit -m "AAA-111: Updated contributor list."`). (If your work in this course is being accounted for by a Jira issue, replace `AAA-111` with that issue&rsquo;s key.)
1. Copy this branch to your Bitbucket repository (`git push`).
1. Proceed to read and follow the instructions in the `README-01.md` file in the `01` directory.

==> tdd-lab.npm/lessons/01/good.css <==
body {
  max-width: 600px;
  margin: 2rem;
}
figcaption {
  font-weight: bold;
  margin: 1rem 0;
}
figure {
  text-align: center;
}

==> tdd-lab.npm/lessons/01/good.html <==
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Logging into Workspace ONE">
    <meta name="keywords" content="telework,authentication,email">
    <meta name="creator" content="The Utopia Group">
    <meta name="publisher" content="The Utopia Group">
    <link rel="stylesheet" href="good.css">
    <title>Logging into Workspace ONE</title>
  </head>
  <body>
    <main>
      <header>
        <h1>Logging into Workspace ONE</h1>
      </header>
      <p>To log into Workspace ONE, browse to <a href="http://workspace.Utopia.com/">http://workspace.Utopia.com/</a>, fill out the form that pops up (with your email address and whether to remember this setting), and click the <q>Next</q> button.</p>
      <figure>
        <figcaption>Workspace ONE login form</figcaption>
        <img
          src="static/ws1login.png"
          alt="Workspace ONE login form with field for email address, checkbox to &ldquo;Remember this setting&rdquo;, and &ldquo;Next&rdquo; button"
        >
      </figure>
    </main>
  </body>
</html>

==> tdd-lab.npm/lessons/01/index.html <==
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Strong Start for Kids 2018 budget">
    <meta name="creator" content="Utopia">
    <meta name="publisher" content="Utopia">
    <link rel="stylesheet" href="lessons/01/style.css">
    <title>Strong Start for Kids 2018 Funding</title>
  </head>
  <body>
    <header>
      <h2>2018 Funding</h2>
    </header>
    <p>The <a href="https://about.Utopia.com/community-stewardship/starting-kids-off-right/">Strong Start for Kids</a> budget is allocated to three drivers of kindergarten success: quality, parents, and systems.</p>
    <figure>
      <p>Allocation of funds in 2018</p>
      <img
        src="static/strongstart.jpg"
        alt
      >
    </figure>
  </body>
</html>

==> tdd-lab.npm/lessons/01/README-01.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 1: A Minimal No-Framework Application

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Configuration](#configuration)
- [Existing tests](#existing)
- [New tests](#new)
- [Why we test](#why)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will practice test-driven UI development with HTML, CSS, and JavaScript. These are the basic languages of the web. You can use them to build web applications. They can be entirely client-side (in-browser) applications, or, by using Node.js, you can implement client-server applications with JavaScript.

In this lesson you will test and finish building a minimal application with these languages.

Utopia UIs are mostly built and tested with frameworks, libraries, content management systems, and/or other software added onto the basic web languages. You will get experience with some of these starting in Lesson 2. But knowledge of HTML, CSS, and JavaScript remains essential for all UI developers. Frameworks supplement and generate code in the basic languages. You continue to code in these languages when using frameworks. You sometimes also need to use these languages to override frameworks when frameworks don&rsquo;t do what you want.

## <a name="setup"></a>Setup

1. In your bash shell, if your working directory is not the `tdd-lab.npm` directory, navigate to it. Verify that this branch (`feature/current`) is shown in parentheses.
1. In your code editor, if this repository is not yet open, open it.

## <a name="configuration"></a>Configuration

1. Open `package.json`.
1. You are going to run tests, located in the file `test.js`. To simplify this operation, add a script to `package.json`. Change `"scripts": {},` to:

   ```json
   "scripts": {
     "test": "node lessons/01/test"
   },
   ```

   This entry will let you enter `npm run test` in your bash shell to execute the code in that file.
1. You are going to create and run some unit tests. For this purpose, you will need a package named `jsdom`, which executes your JavaScript test code approximately as a browser would. Since you will use this package but users of your application will not, it should be a developer dependency only. Therefore, add it to the (currently empty) set of `devDependencies`. The format is the name of the dependency as the key and a version specification as the value. In this case, change `"devDependencies": {}` to:

   ```json
   "devDependencies": {
     "jsdom": "*"
   }
   ```

   This specifies the latest available version.
1. Save `package.json`.
1. Ensure that your npm configuration is compatible with Utopia&rsquo;s npm system. This requires that that the `.npmrc` file in your user home directory (~/.npmrc) contain at least the statements shown in the [example](.npmrc). You can do this by editing your `.npmrc` file.
1. In your bash shell, install `jsdom` and its dependencies (`npm install`). You may ignore warnings about optional and peer dependencies.
1. Expand the directory `node_modules` in your code editor to reveal its subdirectories. One of them should be `jsdom`.

## <a name="existing"></a>Existing tests

Lesson 1 includes two small web pages and fourteen built-in tests that you can run on them.

1. Open `lessons/01/index.html` in Chrome. Possible ways to do this:
   - `start lessons/01/index.html` in your bash shell
   - `open lessons/01/index.html` in the OS X terminal
   - Right-click `lessons/01/index.html` in WebStorm and choose from the menu
   - In Chrome, `CTL/CMD`-`o` or `Open File...`
   - In the File Explorer or Finder, double-click `lessons/01/index.html` if Chrome is your default browser, or right-click or `CTL`-click it and choose to open it in Chrome
1. Note that the page contains:
   - a title in the tab
   - a heading on the page
   - a paragraph of text
   - an image with a caption above
1. In your code editor, open `index.html` and `style.css`. The code in these files determines how the page is rendered in the browser.
1. In your bash shell, run the built-in tests (`npm run test`). This executes the script that you added to `package.json`.
1. Examine the output of the tests. Note the successes (`true`) and the failures (`false`).
1. To understand why the first test was a failure:
   1. Open `test.js` and:
      1. Note that all the test results are initialized as `false`.
      1. Find the `lang` test.
      1. Note that it looks for an `html` element with a `lang` attribute in the document.
      1. Note that, if it finds one, it then asks whether `html.lang` is true or false. `html.lang` is true if the `lang` property has any value other than an empty string. If so, then the script changes the result of that test from `false` to `true`.
   1. In your code editor, open `good.html`. Open that file in your browser, too.
   1. In your bash shell, run the same tests on `good.html` (`npm run test -- good`).
   1. Note that `good.html` passes all the tests except the `altvalue` test. It fails that test because that test is designed specifically for the content of the `index.html` file, not the `good.html` file.
   1. Examine how `good.html` was coded to pass the `lang` test.
   1. Edit `index.html`, with the goal of making it pass the `lang` test. Then save it.
   1. In your bash shell, run the tests on `index.html` again.
   1. Note whether you succeeded in making the file pass the `lang` test. If not, figure out why and correct the problem.
1. Now comes the fun (and the challenge). Do the same for each of the other tests that `index.html` failed. Diagnose each failure, correct it, and retest, until you have made `index.html` pass all the tests.

## <a name="new"></a>New test

Now you will get some practice not only passing tests, but **creating** tests.

1. The `publisher` test currently requires only a non-empty publisher value. But suppose your product owner requires that exactly &ldquo;The Utopia Group&rdquo; be the publisher. Modify the `publisher` test accordingly:
   1. Currently the `publisher` test is one of a set of tests listed in the `metaNames` array, which are run by the statement labeled `meta tests`. They test only for existence and non-emptiness. Your new `publisher` test will be more stringent than that, so remove it from `metaNames`.
   1. Add a test requiring a `meta` element where the publisher is identified exactly as &ldquo;The Utopia Group&rdquo;. The `viewport` test can be a helpful model.
   1. Run the tests and verify that `index.html` **fails** your new `publisher` test.
   1. Amend `index.html` to make it pass that test.
   1. Retest and verify that `index.html` now passes all the tests.
   1. Test `good.html` again. Note that it still passes all the tests, because it originally identified the publisher as &ldquo;The Utopia Group&rdquo;.

## <a name="why"></a>Why we test

The tests in this lesson could have been different, stronger, or weaker. They don&rsquo;t purport to be the &ldquo;right&rdquo; tests. Their purpose is to get you into the rhythm of test-driven development.

But these tests do support, or enforce, some industry standards and generally accepted practices. These include the main web standards (HTML5, CSS3) and also standards of accessibility (WCAG). Utopia complies with these standards so that its UIs work well for a wide range of users, devices, and situations. Standards you have tested for include:

- `lang`: [WCAG 2.1 SC 3.1.1](https://www.w3.org/WAI/WCAG21/Understanding/language-of-page.html)
- `charset`, `description`, `keywords`, `creator`, `publisher`: [HTML5](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#Attributes)
- `viewport`: [WCAG 2.1 SC 1.4.4](https://dequeuniversity.com/rules/axe/3.3/meta-viewport-large)
- `main`: [HTML5](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main)
- `h1`: [HTML5](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements)
- `h1title`: [WCAG 2.1 Technique H42](https://www.w3.org/WAI/WCAG21/Techniques/html/H42)
- `figcaption`: [HTML5](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure)
- `alt`, `altvalue`: [HTML5](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#Authoring_meaningful_alternate_descriptions), [WCAG 2.1 Technique H37](https://www.w3.org/WAI/WCAG21/Techniques/html/H37)
- `textblack`: [WCAG 2.1 SC 1.4.3](https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html)

Pre-built testing tools can perform some&mdash;but only some&mdash;tests for you. Some useful tools:

- [W3C Markup Validation Service](https://validator.w3.org)
- Axe (Chrome and Firefox browser extension)
- WAVE (Chrome browser extension)

You will learn about other testing tools, including some pre-built standard tests, in later lessons.

## <a name="completion"></a>Completion

1. In your bash shell, confirm which files you have changed (`git status`). One might be `package-lock.json`. The [`package-lock.json`](https://docs.npmjs.com/files/package-lock.json) file acts as a log and catalog of your application&rsquo;s dependencies.
1. Look at the changes you have made (`git diff`).
1. Make `git` track those changes (`git add .`).
1. Commit those changes to the index of your local repository (`git commit -m "AAA-111: Added jsdom; passed and strengthened tests."`). (If your work is being accounted for in Jira, change `AAA-111` to the key of the issue you are working under, as in Lesson 0.)
1. Copy your changes to your Bitbucket repository (`git push`).
1. Proceed to read and follow the instructions in the lesson-2 `README` file.

==> tdd-lab.npm/lessons/01/style.css <==
body {
  max-width: 600px;
  margin: 2rem;
}
figure > p {
  margin: 0 0 1rem 0;
  font-weight: bold;
  color: #bbb;
}
figure {
  text-align: center;
}

==> tdd-lab.npm/lessons/01/test.js <==
/*
  Unit tests

  Argument:
  0: base of the name of the .html file to be tested, or 'index' if omitted.
*/

// Imports
const fs = require('fs');
const jsdom = require('jsdom');
const { JSDOM } = jsdom;

// Initialize the test results as failures.
const results = {
  lang: ['lang value on html element', false],
  charset: ['meta element with charset=UTF-8', false],
  viewport: ['meta element with standard viewport value', false],
  description: ['meta element with description value', false],
  keywords: ['meta element with keywords value', false],
  creator: ['meta element with creator value', false],
  publisher: ['meta element with publisher value', false],
  main: ['1 main element', false],
  h1: ['1 h1 element', false],
  h1title: ['h1 element same as title', false],
  figcaption: ['figure element contains figcaption', false],
  alt: ['img alt attribute not empty', false],
  altvalue: ['img element has a fully descriptive alt attribute', false],
  textblack: ['text black', false]
};

// Identify the meta element test names.
const metaNames = [
  'description',
  'keywords',
  'creator',
  'publisher'
];

// Create a document object to perform unit tests on.
const pageString = fs.readFileSync(
  `${__dirname}/${process.argv[2] || 'index'}.html`, 'utf8'
);
// Add a protocol prefix to any file URL to make jsdom recognize it.
const modifiedPageString = pageString.replace(
  /(href|src)="([^:]+)"/g, '$1="file://$2"'
);
const dom = new JSDOM(modifiedPageString, {
  resources: 'usable'
});
const window = dom.window;
const doc = window.document;

// Utility for tests on meta elements.
const metaUtil = metaName => {
  const element = doc.querySelector(`head meta[name=${metaName}]`);
  const content = element && element.getAttribute('content');
  if (content && content.length > 0) {
    results[metaName][1] = true;
  }
};

// After page is loaded:
window.onload = () => {
  // Perform the unit tests.

  // lang
  const htmlWithLang = doc.querySelector('html[lang]');
  if (htmlWithLang && htmlWithLang.lang) {
    results.lang[1] = true;
  }
  // charset
  if (doc.querySelector('meta[charset=UTF-8]')) {
    results.charset[1] = true;
  }
  // viewport
  if (doc.querySelector(
    'meta[name=viewport][content="width=device-width, initial-scale=1"]'
  )) {
    results.viewport[1] = true;
  }
  // meta tests
  metaNames.forEach(metaName => {
    metaUtil(metaName);
  });
  // main
  if (doc.querySelectorAll('main').length === 1) {
    results.main[1] = true;
  }
  // h1 and h1title
  const h1s = doc.querySelectorAll('h1');
  if (h1s.length === 1) {
    results.h1[1] = true;
    if (h1s[0].textContent === doc.querySelector('title').textContent) {
      results.h1title[1] = true;
    }
  }
  // figcaption
  const fig = doc.querySelector('figure');
  if (! fig || fig.querySelector('figcaption')) {
    results.figcaption[1] = true;
  }
  // alt and altvalue
  // Identify the first image.
  const img = doc.querySelector('img');
  if (img) {
    // There is an image.
    const alt = img.alt;
    if (alt !== undefined) {
      // There is an alt attribute on it.
      results.alt[1] = true;
      if ([
        '2018', '3.1', '2.6', '1.1', 'quality', 'parents', 'systems'
      ].every(item => alt.toLowerCase().includes(item))) {
        // The value of alt includes all the facts.
        results.altvalue[1] = true;
      }
    }
  }
  else {
    // There is no image, so no alt is required.
    results.alt[1] = true;
    results.altvalue[1] = true;
  }
  // textblack
  const textElements = Array.from(
    doc.querySelectorAll('h1, h2, p, figcaption')
  );
  // Check whether each element has black or no specified color style.
  if (textElements.every(element => {
    const style = window.getComputedStyle(element);
    const color = style.getPropertyValue('color');
    // getPropertyValue('color') converts hex to rgb.
    return ! color || ['black', 'rgb(0, 0, 0)'].includes(color);
  })) {
    results.textblack[1] = true;
  }

  // Output the results.
  console.log(JSON.stringify(results, null, 2));
};

==> tdd-lab.npm/lessons/02/README-02.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 2: A Minimal Angular Application

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Configuration](#configuration)
- [Testing](#testing)
- [Examining the application](#examining)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will create a copy of the Utopia exemplar Angular application and inspect it.

In Lesson 1 you practiced test-driven development of a UI with the basic languages of the web: HTML, CSS, and JavaScript. At Utopia, UIs are mostly built and tested with frameworks, libraries, content management systems, and/or other software added onto these basic languages. The most common UI framework at Utopia is [Angular](https://angular.io/), an open-source platform originally developed by Google.

Not all Utopia applications are based on Angular. Some are based on an earlier version of Angular, named [AngularJS](https://angularjs.org/). Some are based on [React](https://reactjs.org/), [Vue](https://vuejs.org/), or externally hosted platforms, such as [brandworkz](https://brandworkz.com).

 Because of its wide use at Utopia, Angular is the framework used in the remaining lessons of this course.

 Angular is complex. This course will not teach you how Angular is implemented. It **will** teach you how, starting with Utopia&rsquo;s Angular exemplar, to create an application that performs a practical service. In the process, you will continue to learn and practice test-driven development.

## <a name="setup"></a>Setup

1. In your browser, go to [the repository of the Angular exemplar]().
1. Create a fork of that repository into your own Bitbucket project. Instead of accepting the default name `exemplar.angular` in the &ldquo;Create fork&rdquo; dialog, give your fork the name `crewinfo`, to express the service that your application will provide.
1. In your fork, open &ldquo;Repository settings&rdquo;.
1. In &ldquo;Repository permissions&rdquo;/&ldquo;Group access&rdquo;, grant &ldquo;Read&rdquo; permission to the group `rol bitbucket user dvt` and press &ldquo;Add&rdquo;. (Also enable &ldquo;Public access&rdquo; if you wish.)
1. Enable &ldquo;Web Pages&rdquo; for the `master` branch and new branches.
1. Under &ldquo;Hooks&rdquo;, turn off &ldquo;Yet Another Commit Checker&rdquo; if it is on.
1. Return to &ldquo;Source&rdquo;.
1. Clone your fork into a new repository on your local machine. You will do your work from now on in that repository, which by default will be named `crewinfo`.
1. In your bash shell, navigate to your new `crewinfo` repository. Verify that you are currently in the `master` branch.
1. Create a copy of the `master` branch and switch to it (`git checkout -b feature/current`). You will do your work in the `feature/current` branch. Your work can later be merged into the `master` branch when you are ready for that.

## <a name="configuration"></a>Configuration

1. In your code editor, if your clone of `tdd-lab.npm` is not yet open, open it.
1. Open a **new** window in your code editor, and in that window open your new `crewinfo` repository. Verify that your code editor shows `feature/current` as the active branch.
1. Open `package.json` in both repositories. Copy these entries from the `tdd-lab.npm` file into the `crewinfo` file, replacing the same entries if they exist:
   1. `version`
   1. `description`
   1. `keywords`
   1. `contributors`
   1. `repository`
1. Correct the `repository` name in `package.json` by replacing `tdd-lab.npm` with `crewinfo`.
1. Correct the `name` value by replacing `angular.exemplar` with `crewinfo`.
1. Add the `devDependencies.jsdom` entry of `package.json` in `tdd-lab.npm` to the `devDependencies` entry in `crewinfo`.
1. In your bash shell, list your `npm` configuration (`npm config list`). One of the entries in the `userconfig` section should be

   ```shell script
   CYPRESS_INSTALL_BINARY = ""
   ```

   if you are using Windows or

   ```shell script
   CYPRESS_INSTALL_BINARY = ""
   ```

   if you are using OS X. In that entry, `n.n.n` should be replaced by the version of the `cypress` package listed in the `devDependencies` entry of the `package.json` file. If that entry is not in the `userconfig` section, or if it is there with the wrong version of Cypress, add the correct entry with the command:

   ```shell script
   npm config set CYPRESS_INSTALL_BINARY ...
   ```

   As above, replace `n.n.n` with the correct version. For details, see [http://confluence.Utopia.com:8090/display/CYPRESS/Cypress](http://confluence.Utopia.com:8090/display/CYPRESS/Cypress).

1. Uninstall the obsolete and install the newly required dependencies (`npm install`). Wait for completion, which takes about 10 minutes. (While waiting, you can read ahead in this and later lessons&rsquo; `README.md` files, to get familiar with what you will be doing.) You may ignore warnings about optional and peer dependencies. If you see a &ldquo;Can't find Python executable&rdquo; error, you can ignore that, too.

## <a name="testing"></a>Testing

1. In your bash shell, perform this application&rsquo;s built-in linting (`npm run lint`). The output should show that the code contains no errors, though there may be warnings.
1. Perform the built-in Jest tests (`npm run test:unit`). This will run Jest and Istanbul. After about 2 minutes, results should appear in your bash shell. The Istanbul results should include a table of statistics of test coverage. After that table, the Jest results should show the number of test suites and tests, and how many of them the branch passed. The branch should have passed all the tests.
1. Istanbul also created HTML documents reporting coverage results. They are in `reports/coverage/unit/lcov-report/`. Open these in the web browser to see what the tests did and did not cover:
   1. `index.html`
   1. `src/app/index.html`
   1. `src/app/app.module.ts.html`
   1. `src/app/app.component.ts.html`
1. At the end of the results you should see the path to a test report. In the `reports/cucumber` directory, open the specified file in your web browser. You should see the tests described. As you develop your application, you will add to and modify the first test suite, the component tests.
1. Perform the built-in Cypress tests (`npm run test:e2e`). Cypress will open the application in a browser window, perform tests, open and close a window in its own browser, and output the result in your bash shell. The result should show that 1 test was performed and the branch passed it. Cypress may fail to quit properly and emit an error message, but you can ignore that.
1. Perform the built-in mutation tests (`npm run test:mutation`). This will run Stryker. The mutation testing may take up to half an hour. (While they run, you can continue working.) The results should appear in your bash shell. Error messages may also appear, but they don&rsquo;t require any action by you. Mutations are random changes to the code that may make the branch fail tests. The results should show that the mutations did that (&ldquo;killed&rdquo; or &ldquo;timeout&rdquo;) in some cases, but did not (&ldquo;survived&rdquo;) in other cases.
1. Stryker should have saved an HTML report in `reports/coverage/mutation/index.html`. Open that file in your web browser. Follow the `app` link to open a more detailed report. Follow the `app.component.ts` link there to open a detailed report on the root component of the application. Note that the report has three buttons to reveal more information.

## <a name="examining"></a>Examining the application

In your code editor, open and look through the directories and files that are now in your application. The files in `src/app` are the main files. Other files in `src` and in the main directory support the application. The files whose names include `spec`, `jest`, `e2e`, `cypress`, or `stryker` support testing. The packages that the application depends on are stored in the `node_modules` directory.

Some of these files will become relevant in future lessons. You will examine them more carefully then.

## <a name="completion"></a>Completion

1. Confirm which files you have changed (`git status`).
1. Make `git` track those changes (`git add .`).
1. Commit those changes to the index of your local repository (`git commit -m "AAA-111: Forked and cloned exemplar, created feature branch, customized package.json."`).
1. Copy this branch to your Bitbucket repository (`git push -u origin feature/current`).
1. Proceed to read and follow the instructions in the lesson-3 README file.

==> tdd-lab.npm/lessons/03/README-03.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 3: Static Content

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Planning](#planning)
- [Test, fail](#test)
- [Revise, pass](#revise)
- [Rename](#rename)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will give your application some basic UI elements.

In Lesson 2 you saw that the Utopia Angular exemplar comes with a few tests. In this lesson you will revise some of those tests and create new ones to specify requirements for UI elements in the application you plan to create. Then you will revise the exemplar application until you make this branch pass all of the tests.

In doing so, you will become more familiar with tools for performing tests on Angular applications.

## <a name="setup"></a>Setup

1. In your bash shell, if your working directory is not the `crewinfo` directory, navigate to it. Verify that the `feature/current` branch is shown in parentheses.
1. In your code editor, if the `crewinfo` repository is not yet open, open it. Verify that `feature/current` is shown as the active branch.
1. Open the `angular.json` file. Find the entry `projects.exemplar-angular.architect.serve.options.host` (following the path of object properties starting with `projects` ). If its value is `"localhost.Utopia.com"`, change it to `"localhost"`. That will let you develop when you don&rsquo;t have Internet access. Save the file.
1. In the `tdd-lab.npm` repository on Bitbucket in your browser, open the `README-switch.md` file and follow the &ldquo;Setup&rdquo; instructions. (You may see error messages in your Jest testing window saying a worker process has failed to exit gracefully. You may ignore those.)
1. Decide whether your JavaScript and TypeScript quotation style will use single or double quotes for strings. (Subsequent lessons in this course are formatted with single quotes.) If you prefer single quotes (`'`) rather than double quotes (`"`), implement that choice:
   1. In your code editor, open `.eslintrc.json`. It contains an `"overrides"` property, whose value is an array. Each element of the array applies a list of rule overrides to files of particular types. Find the element that applies rule overrides to files matching `*.js`. Add the entry `"quotes": ["error", "single"]` to that element&rsquo;s `"rules"` property, if such an entry is not already there. Save the file.
   1. Edit `.prettierrc` to add an entry `"singleQuote": true` to the top-level object, if such an entry is not already there. Save the file.
   1. In your bash shell, run `prettier` on the files of the branch (`npm run format`).
1. Decide whether your JavaScript and TypeScript style will require semicolons at the ends of statements. The bulk of expert opinion favors requiring semicolons, but developers differ on this. The instructions in this course show semicolons included. To specify your choice, edit `.prettierrc` to make the value of `"semi"` `"true"` (to require semicolons) or `"false"` (to remove them).

## <a name="planning"></a>Planning

You will build an application that lets users search for information about Utopia crew members. Its minimum version will contain:

1. a view (page) title, displayed in a browser tab
1. a view (page) heading
1. a Utopia logotype
1. a search input field
1. a label for the search input field
1. a submission button

In this lesson you will put these elements into the application in a reasonable order, and in conformity with industry standards. They won&rsquo;t look pretty yet. They won&rsquo;t do anything yet. You will work on those refinements in later lessons.

You will now begin test-driven development (TDD). TDD has various flavors. Some practitioners prefer to create one test at a time, write the code that will pass that test, and verify the success of the code. Others prefer to [write tests in &ldquo;cycles&rdquo;](https://www.selenium.dev/documentation/en/introduction/types_of_testing/#test-driven-development-tdd), with each cycle containing several related tests, before writing code to pass all the tests in the cycle. In this lab there will be cycles containing a few tests each.

## <a name="test"></a>Test, fail

1. Create a test for the view title.
   1. What to test for: The first element listed above is a view title. It will be &ldquo;Search Form: Utopia Crew Search&rdquo;. One of the industry standards on titles is [WCAG SC 2.4.2](https://www.w3.org/WAI/WCAG21/Understanding/page-titled.html). It requires each page to have a unique title. This makes the site more accessible, allowing users to know, from the title alone, which page they are on. It is also an industry best practice to put the view-specific part at the beginning of a title. This helps users identify views even when browser tabs are not wide enough to show entire titles. The title quoted above conforms to these standards. &ldquo;Utopia Crew Search&rdquo; titles the whole application, and &ldquo;Search Form&rdquo; titles this view.
   1. Where to test: The Utopia exemplar contains two built-in testing platforms: Jest and Cypress. Typically, Jest is used for _unit tests_ (tests of individual units of software), and Cypress is used for _integration tests_ (tests of two or more units of software in combination). In reality, the boundary between unit and integration tests is imprecise, and sometimes a limitation of Jest or Cypress forces you to use the other platform for a specific test, regardless of its type. In this case, you are testing an element within the `head` element of an HTML document. In the Utopia exemplar, Jest has access to the contents of the `body`, but not the `head`, element. Therefore, you must use Cypress for this test. In your code editor, open the `e2e/src/integration/app.spec.ts` file. That is where the Cypress tests are.
   1. How to test: Cypress provides a `title()` method for retrieving the title from its browser. Open the `e2e/src/support/app.po.ts` file and add this statement to it (if not already there):

      ```typescript
      export const getTitle = () => cy.title();
      ```

      Return to the `app.spec.ts` file. To use the `getTitle()` function, add this statement at the top of the file (if not already there):

      ```typescript
      import { getTitle } from '../support/app.po';
      ```

      After the `import` statement, add this Cypress test for the title, or, if there already is a title test in the file, revise it:

      ```typescript
      describe('Home view', () => {
        beforeEach(() => cy.visit('/'));
        it('title should be Search Form: Utopia Crew Search', () => {
          getTitle().should('equal', 'Search Form: Utopia Crew Search');
        });
      });
      ```

      (You are free to use `'` or `"` for quotations in TypeScript.) Save the file. When the Cypress tests run again, the branch should now fail the test that you have revised.
1. Create a test for a header landmark followed by a main landmark, as the only children of the document body.

   1. What to test for: A standard HTML document&rsquo;s `body` element has these child elements:

      - optionally, one [`header` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header)
      - one [`main` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main)
      - optionally, one [`footer` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer)

      These are _landmark_ elements. There might be others, but your application&rsquo;s home view will include only header and main content. So the component template (`app.component.html`), which specifies the content of the document&rsquo;s `body` element, should have only two top-level elements, a `header` element and a `main` element.

   1. Where to test: The `body` element&rsquo;s content is defined by the root component of the application, in `src/app`. In that directory, open the `app.component.spec.ts` file in your code editor. That file contains the Jest tests for the root component.
   1. How to test:

      1. The file needs an infrastructure that will support Jest tests. The file should already contain such an infrastructure, looking like this:

         ```typescript
         import { ComponentFixture, TestBed } from '@angular/core/testing';
         import { RouterTestingModule } from '@angular/router/testing';
         import { AppComponent } from './app.component';
         import { environment } from './../environments/environment';

         describe('AppComponent', () => {
           let fixture: ComponentFixture<AppComponent>;
           let app;
           let compiled;
           const title = 'exemplar';

           beforeAll(() => {
             TestBed.configureTestingModule({
               imports: [RouterTestingModule],
               declarations: [AppComponent],
             }).compileComponents();
             fixture = TestBed.createComponent(AppComponent);
             app = fixture.debugElement.componentInstance;
             fixture.detectChanges();
             compiled = fixture.debugElement.nativeElement;
           });
           …
         });
         ```

      1. If that is how the file begins, change `beforeAll` to `beforeEach`. By doing that, you will cause the function argument to be executed before each test, instead of only once. That will ensure that the operations performed by one test don&rsquo;t affect the results of later tests.
      1. If the file contains statements importing and initializing an `environment` object, delete those statements, and any test that uses it, because your application will not need that test.
      1. Add a test requiring the view to have a `header` element immediately followed by a `main` elements. If there is a create-the-app test in the file already, add this new test after that test. Here is code for the new test:

         ```typescript
         it('should have a header landmark and then a main landmark', () => {
           expect(compiled.querySelector('header + main')).toBeTruthy();
         });
         ```

         The `+` operator specifies that two elements are adjacent siblings. When you save the file, Jest should rerun its tests. The branch should fail this test.

1. Create a test for a view heading.

   1. What to test for: Headings are a major contributor to a usable and accessible document. The [WCAG G141](https://www.w3.org/WAI/WCAG21/Techniques/general/G141) standard recommends that heading levels express the logical relationships in the content, starting with an `h1` heading at the top. A common practice, at Utopia and elsewhere, is to have only one `h1` heading in a view.
   1. How to test:

      1. Delete any tests for a title that you find in the file, and any definition of a `title` constant in the callback argument to the main `describe()` function. You have created a Cypress test for the title.
      1. Add a test for the existence of one and only one `h1` element, with this code:

         ```typescript
         it('should contain exactly 1 h1 heading', () => {
           expect(compiled.querySelectorAll('h1').length).toBe(1);
         });
         ```

         The branch may pass or fail this test, depending on the version of the exemplar that you forked.

1. Create a test for the location of the view heading.
   1. What to test for: The `header` element is the appropriate home for the view heading. Make your test require the `h1` element to be there.
   1. How to test: You can use this code:

      ```typescript
      it('its h1 heading should be in the header', () => {
        expect(compiled.querySelector('header h1')).toBeTruthy();
      });
      ```

      The `'header h1'` selector will select an `h1` element if it is a descendant (not necessarily a child) of a `header` element.
1. Create a test for the content of the view heading.
   1. What to test for: An industry best practice is to make the content of the view heading identical to the view title. That tells the user what the current view is about, whether the user is paying attention to the browser tabs or to the top of the page. So, this test will expect the `h1` element to have &ldquo;Search Form: Utopia Crew Search&rdquo; as its content.
   1. Where to test: This will be a Jest test, like the previous one. The rest of the tests in this lesson will likewise be Jest tests.
   1. How to test: Add this code after the previous test:

      ```typescript
      it('its h1 heading should restate the view title', () => {
        expect(compiled.querySelector('h1').textContent.trim()).toBe(
          'Search Form: Utopia Crew Search'
        );
      });
      ```

      The `textContent` property of an element is whatever text, including white space, is inside the element. The `trim()` method disregards any leading or trailing white space, such as newlines and indentations.

      Obviously, the branch should fail this test. The Jest output in your bash shell should identify the failing test.
1. Create a test for the Utopia logotype.
   1. What to test for: For now it will be enough to verify that the view template specifies an image, inside the `header` element, to be loaded from a correctly named file.
   1. How to test: This code will accomplish that:

      ```typescript
      it('its header should contain the Utopia logotype', () => {
        expect(
          compiled.querySelector('header img[src$="Utopia-logo.svg"]')
        ).toBeTruthy();
      });
      ```

      Note the syntax of the attribute selector. the `$` suffixed to `src` makes this selector say &ldquo;Select the first `img` element with a `src` attribute whose value **ends** with `Utopia-logo.svg`&rdquo;. If such an element exists in the view, the branch will pass this test.
1. Create a test for the logotype&rsquo;s alternative text.
   1. What to test for: Every `img` element is expected to have an `alt` attribute, either without any value (if the image is purely decorative) or with a value that explains the image sufficiently to a user who can&rsquo;t see the image. The `alt` attribute is [recommended by Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img) and is the [standard technique](https://www.w3.org/WAI/WCAG21/Techniques/html/H37) for satisfying the [WCAG SC 1.1.1](https://www.w3.org/WAI/WCAG21/Understanding/non-text-content) standard for text alternatives to non-text content. Where an image is a logotype, it is enough to restate the portrayed text as the value of `alt`.
   1. How to test: Copy the previous test and use it as the basis for this test. Change the first argument of `it()` appropriately (such as `'its Utopia logotype should be restated as text'`). Change the argument of `querySelector()` by appending this attribute selector to it: `[alt=Utopia]`. The branch should pass this test if the exemplar contains a `header` element that in turn contains the Utopia logotype with `'Utopia'` as the value of its `alt` attribute.
1. Create a test for a search input field with an ID in the `main` element.
   1. What to test for: HTML `input` elements have [more than 20 possible types](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). For a search query, the appropriate type is `"search"`.
   1. How to test: This test will work:

      ```typescript
      it('main should contain a search input field with ID query', () => {
        expect(
          compiled.querySelector('main input#query[type=search]')
        ).toBeTruthy();
      });
      ```

      The selector `main input#query` looks for a `main` element that contains an `input` element that has an `id` attribute with the value `"query"`. So this test requires that the `input` element assign specific values to two attributes: `id` and `type`. The branch should fail this test.
1. Create a test for the labeling of the query input field.

   1. What to test for: An `input` element is a kind of form control, and form controls need labels so that users can know what they are for, as required by the [WCAG SC 3.3.2 standard](https://www.w3.org/WAI/WCAG21/Understanding/labels-or-instructions). The [WCAG SC 1.3.1 standard](https://www.w3.org/WAI/WCAG21/Understanding/info-and-relationships) also requires code to associate labels with the controls that they label, so algorithms employed by users can reliably interpret the labels. Labels are trickier than you might suppose. Imagine an input field with `Name` above or to one side of it. Is that an adequate label? Generally not, because, among other reasons:

      - It may not be understood to be a label of the `input` element merely by being near it, especially if the user is blind and only knows what order the `input` element and the word are in.
      - It doesn&rsquo;t say **whose** name is required (the user&rsquo;s or another person&rsquo;s).
      - It doesn&rsquo;t say whether an entry is **required**.
      - It doesn&rsquo;t say whether the entire name is required or only a fragment of a name.
      - It doesn&rsquo;t say whether the name must be case-sensitive.

      A robust UI has labels that answer such questions.

   1. How to test: An `input` element has a `labels` property, whose value is a NodeList of the `label` nodes in the DOM that label the element. Create a test that expects only one labeling node, with text content saying &ldquo;Name to search for (part or whole, case-insensitive, or leave blank to show all names)&rdquo;. You can use this code:

      ```typescript
      it('query input field should be thoroughly labeled', () => {
        const queryInput = compiled.querySelector('#query');
        expect(
          queryInput &&
            queryInput.labels.length &&
            queryInput.labels.item(0).textContent.trim()
        ).toBe(
          'Name to search for (part or whole, case-insensitive, or leave blank to show all names)'
        );
      });
      ```

      The branch should fail this test.

1. Create a test for a button in the main landmark.
   1. What to test for: Your application will offer a button for submitting the search form. The standard implementation is a `button` element.
   1. How to test: Your test for a search `input` field can be reused here, with `main button` as the selector. The branch should pass this test if it contains a `button` element in the `main` element.
1. Create a test for the type of the button.
   1. What to test for: The standard type of a `button` element that submits a form is `submit`. Buttons can have a `type` attribute. If you want a button to have a `type` property other than `'submit'`, you use the `type` attribute to assign a different type to the button.
   1. How to test: You can reuse your test for the search `input` field here, by making appropriate changes. One change is not obvious, however. Since `submit` is the default type, a button with that type can have a `type="submit"` attribute or have no `type` attribute at all. The selector that covers both of these possibilities is `'main button[type=submit], main button:not([type])'`.
1. Create a test for the text content of the button.
   1. What to test for: The conventional text content of a submission button is &ldquo;Submit&rdquo;.
   1. How to test: You can test for the text content with this code:

      ```typescript
      it('its first button should have the text Submit', () => {
        const firstButton = compiled.querySelector('main button');
        expect(firstButton && firstButton.textContent.trim()).toBe('Submit');
      });
      ```

      The branch should fail this test.

1. Create a test for input fields and buttons belonging to forms.
   1. What to test for: The [standard practice](https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Your_first_HTML_form) to enclose user-operated HTML controls in a `form` element.
   1. How to test: Controls, including `input` and `button` elements, have a `form` property. When such an element is inside a `form` element, the `form` property has that `form` element as its value. When there is no `form` element, the `form` property has the value `null`. Add this test to your Jest tests to ensure that each `input` and `button` element belongs to a form:

      ```typescript
      it('all inputs and buttons should belong to forms', () => {
        expect(
          Array.from(compiled.querySelectorAll('input, button'))
            .map(control => control[`form`])
            .every(form => form !== null)
        ).toBeTruthy();
      });
      ```

      The `querySelectorAll()` method returns a NodeList, a collection of nodes similar to an array but without some array methods. the `Array.from()` method converts it to an array. Then the `map()` method converts each input and button in the array into the value of its `form` property. Finally, the `every()` method checks whether every one of those values is non-null.

      The branch should pass this test if the view contains no inputs and no buttons, because the array will then be empty, and an empty array&rsquo;s `every` method returns `true`.

## <a name="revise"></a>Revise, pass

1. You have created tests for this branch of your application to pass. Now you will make the branch pass them. After each revision, save the file(s), note the effect on the test results, and if necessary debug.
1. To start, make the branch pass your Cypress title test.
   1. First, open `app.component.ts`. Since your application will not need an `environment` variable, delete any statement importing, initializing, or using that variable.
   1. Ensure that the `AppComponent` class has a `title` member whose value is the desired view title. Save the file.
   1. Then open `index.html` and change the title to your view title.
   1. The branch should now pass your title test. If it doesn&rsquo;t, remember that you may need to resynchronize Cypress by pressing the &ldquo;Run all tests&rdquo; button just above the Cypress command log.
1. Then make the branch pass the Jest test for `header` and `main` elements. If those elements do not yet exist at the top level of the `app.component.html` file, put them there. For now, you can simply insert

   ```angular2html
   <header></header>
   <main>
   </main>
   ```

   at the top of the file and then put everything else into the `main` element.
1. Make the branch pass the test for a single view heading, if it doesn&rsquo;t yet do so. For this test, the `h1` element can be anywhere in the `app.component.html` file.
1. Make the branch pass the test for the view heading&rsquo;s location.
1. Make the branch pass the test for the text content of the view heading. You can do this by changing the text content of the `h1` element in `app.component.html`. Make it the interpolated value of `title` and nothing else. An interpolated value looks like `{{ title }}`.
1. Make the branch pass your test for the Utopia logotype. If it doesn&rsquo;t, add this element inside the `header` element, above the `h1` element:

   ```angular2html
   <img src="assets/Utopia-logo.svg">
   ```

1. Make the branch pass your test for the text alternative to the logotype. Do this by adding an `alt` attribute to the `img` element, or, if there is one already, changing its value to `"Utopia"`.
1. Make the branch pass your test for an input field. To do this, add a `p` element (with opening and closing tags) inside the `main` element, and then an `input` element inside the `p` element. An `input` element has only one tag. Although this should make the branch pass the input test, it should also make the branch **fail** the form test, if the view previously contained no inputs or buttons. You will correct that below.
1. Make the branch pass your test for the type and ID of the input field. To do this, add `type` and `id` attributes to the `input` element, with the values expected by the test.
1. Make the branch pass your test for input labeling. There are three basic mechanisms for labeling an input. Here they are:

   1. Explicit:

      ```angular2html
      <p><label for="inputid">I am a label</label></p>
      <p><input id="inputid"></p>
      <p><label for="inputid">I am another label</label></p>
      ```

   1. Shared (because multiple inputs can share a label):

      ```angular2html
      <p id="label1">I am a label</p>
      <p><input aria-labelledby="label1 label2"></p>
      <p id="label2">I am another label</p>
      ```

      (The `span` elements could be `p`, `div`, or other elements.)
   1. Implicit:

      ```angular2html
      <p>
        <label>
          I am a label
          <input id="inputid">
          And so am I
        </label>
      </p>
      ```

      In the explicit and shared mechanisms, the labeling elements can be located anywhere. Their contents are concatenated.

      Your test relies on the `labels` property of the `input` element. Only the mechanisms that use a `label` element&mdash;namely, the first and third mechanisms&mdash;set that property. So try both mechanisms. Your test also expects the entire label to be in one element. In mechanism 1, that means you should use only one `label` element, either before or after the `input` element. In mechanism 3, you **can** split the label, putting part of it before and the rest after the `input` element, because it is entirely within a single `label` element. Try it both ways and verify that the branch passes the test. For this view, mechanism 1, with the `label` element before the `input` element, will produce the best layout without additional work, so leave mechanism-1 labeling in effect.

1. Make the branch pass your button test. Do this by adding an empty `button` element inside a `p` element (`<p><button></button></p>`) inside the `main` element, after the `p` element containing the `input` element.
1. The branch should pass both of your button-type tests because the button that you added, by default, has `'submit'` as the value of its `type` property. Verify this by temporarily adding a `type="button"` attribute to the `button` element. That should make the branch fail both of those tests. Change the value to `"submit"`. That should make the branch pass the tests. You can leave the attribute there are remove it, as you prefer.
1. Make the branch pass your test for the text content of the button. Do this by inserting `Submit` between the tags of the `button` element.
1. Make the branch pass your form test by enclosing the `p` elements that contain the `input` and `button` elements in a `form` element. (It would make sense to enclose the `p` element containing the label, too, in the `form` element.) Now the branch should pass all of the tests.

## <a name="rename"></a>Rename

1. You previously named your fork of the Utopia Angular exemplar repository `crewinfo`, but the original name persists within the application. Start to rename it from `exemplar` to `crewinfo` in the `angular.json` file. Wherever `"exemplar"` appears in that file, change it to `"crewinfo"`.
1. In the `app.component.ts` file, in the argument to the `@Component` decorator, change the value of `selector` from `'exemplar-root'` to `'crewinfo-root'`.
1. Make the same change in the component name in `index.html`. After these changes, the branch should continue to pass all tests.

## <a name="completion"></a>Completion

Your new tests and revisions have started to convert this application from the exemplar to one that will perform useful work, while also ensuring conformity to industry and Utopia standards and best practices.

1. Open the `README-switch.md` file in your browser and follow the &ldquo;Completion&rdquo; instructions.

==> tdd-lab.npm/lessons/04/home-minimum.png <==
==> tdd-lab.npm/lessons/04/README-04.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 4: Basic Styling

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Cleanup](#cleanup)
- [Test, fail](#test)
- [Revise, pass](#revise)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will build a stylesheet to improve the appearance of the application.

In Lesson 3 you added application-specific content to the Utopia Angular exemplar. You also amended and added tests to ensure that your new content complies with applicable industry standards, and then you made the branch pass your tests.

You have done almost nothing yet to refine the visual appearance of the content. Your focus shifts in this lesson to that aspect, i.e. &ldquo;style&rdquo;. You will specify some style goals, create tests to enforce them, and then make this new branch pass those tests.

The tests you created in lesson 3 will remain useful here, too. They will ensure that your work on styles does not undo your success in making the content standard-compliant.

## <a name="setup"></a>Setup

1. Open the `README-switch.md` file in your browser and follow the &ldquo;Setup&rdquo; instructions.

## <a name="cleanup"></a>Cleanup

1. When adding elements to the exemplar, you did not remove any existing elements. Now, in `app.component.html`, remove any content that your application will no longer need. This includes, if present:

   1. A comment about the content being just a placeholder.
   1. Any `pre` element.
   1. Any `h2` element.
   1. Any `ul` element.
   1. Any `div` element.
   1. Any `router-outlet` element.
   1. A `width` attribute of the `img` element.
   1. Any `style` attribute.
   1. Any comment.

   This should leave a `header` element containing an `img` and an `h1` element, and a `main` element containing a `form` element. The view should look **somewhat** like the image below.

1. Check on whether the actions you just took caused the branch to fail any Cypress tests. If so, find and remove any obsolete Cypress tests.
1. Check on whether the removals caused the branch to fail any Jest tests. If so, find and remove any obsolete Jest tests.
1. You have removed references to the `environment` variable from the template, so your application no longer needs it. Remove both its import statement and its initialization statement from `app.component.ts`.

![Minimum home view](home-minimum.png)

## <a name="test"></a>Test, fail

You will need tests for styles. If you define styles inside the HTML template, you can test styles with Jest. But, as advised by the [Mozilla Foundation](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style), it is a better practice to &ldquo;put your styles into external stylesheets&rdquo;. If you do that, you can&rsquo;t test them with Jest, because Jest uses Jsdom and Jsdom (at least by default and in Jest) does not apply external stylesheets. So you will, as recommended, use an external stylesheet, and therefore use Cypress for style tests.

Styles that you define will affect properties of elements. They will generally affect the `style` property. Sometimes they will also affect other properties. Your tests will check on whether properties have the values that you expect.

You will start with tests for the styles of buttons. You will make your tests generic, on the assumption that you may later have more than one button and you will want all the buttons to conform to particular standards.

1. Create a group for button tests in `e2e/src/integration/app.spec.ts`. Use this code:

   ```typescript
   describe('buttons', () => {
     // Tests will be here.
   });
   ```

   This code should be located under the last test, indented the same as the test, before the closing line of the outer `describe()` function.
1. As the first statement in the button group, replacing the &ldquo;Tests will be here.&rdquo; comment, define a function that will make it easy to test button properties. Here is code for that function:

   ```typescript
   const testProperty: (n: string, c: string, v: string | number) => void = (
     name,
     criterion,
     value
   ) => {
     cy.get('button').each($button => {
       cy.wrap($button.prop(name)).should(criterion, value);
     });
   };
   ```

   The format of this function incorporates the static typing of TypeScript. While the JavaScript equivalent of the first line would be `const testProperty = (`, TypeScript appends to `testProperty` a type. The type is a function type. So it is a composite of the argument types (string, string, and either string or number) and the result type (void).

   The Cypress `cy.get()` command returns all of the elements selected by the selector argument (similarly to `querySelectorAll()`). The `each()` method iterates through that collection, wrapping each element in a JQuery element. That allows using the JQuery `prop()` method to return a specified property of the element. The `cy.wrap()` command converts that returned value to a Cypress value, allowing the Cypress `should()` method to be applied to it. The `should` method takes a `criterion` argument such as `'equal'` or `'greaterThan'`, and a value to be compared with the property value.

   In case you are curious, here is some additional information about this function (if not, you can ignore it and proceed to the next step): The callback function of the `each()` method could have been:

   ```typescript
   cy.wrap($button)
     .invoke('prop', name)
     .should(criterion, value);
   ```

   That statement would have converted `$button` from a JQuery to a Cypress element, letting us to use the Cypress `invoke()` method, which would convert the element back to a JQuery element and call the JQuery `prop()` method on it.

   If you wanted to test only the first of several buttons, the function body could have been:

   ```typescript
   cy.get('button')
     .first()
     .invoke('prop', name)
     .should(criterion, value);
   ```

1. Define another function that will make it easy to test subproperties of the `style` property of each button. Use this code:

   ```typescript
   const testStyle: (s: string, v: string) => void = (style, value) => {
     cy.get('button').each($button => {
       cy.wrap($button).should('css', style, value);
     });
   };
   ```

   This function uses the Cypress `css` _chainer_ to return a specified subproperty of the `style` property of the element and compare it with a specified (string) value.

   If you are curious: An alternative way to formulate the `each` callback function, using the JQuery `css` method instead, would have been:

   ```typescript
   cy.wrap($button.css(style)).should('equal', value);
   ```

1. As the first test in this new group, insert this code to require the text in buttons to be white:

   ```typescript
   it('should have white text', () => {
     testStyle('color', 'rgb(255, 255, 255)');
   });
   ```

   The `color` style property may be defined in various systems (RGB, HSL, HEX, or names), but it is reported in RGB, so this test uses RGB to describe &ldquo;white&rdquo;. Because the text of the button is currently not white, the branch should fail this new test.
1. Add a similar test requiring the **background** color of buttons to be Utopia red. The style property is `'backgroundColor'`, and Utopia Red (`#96151d` in Hex) is `rgb(150, 21, 29)`. The branch should fail this test, too, since the current background of the button is the browser&rsquo;s default.
1. It is helpful to users to distinguish buttons from highlighted text. The [WCAG SC 3.2.4](https://www.w3.org/WAI/WCAG21/Understanding/consistent-identification.html) standard requires consistent identification of functional elements across a site. One simple way to distinguish buttons is to shape them like rounded rectangles. Add a similar test requiring buttons to have rounded corners with a radius of 8 pixels. The style property is `'borderRadius'`, and the value 8 pixels will be reported as `'8px'`. Currently the button has no corner rounding, so its `borderRadius` style property is `'0px'`, and the branch should fail this test.
1. Check the size of the button, using the browser&rsquo;s developer tools. In the &ldquo;Properties&rdquo; pane of the &ldquo;Elements&rdquo; panel, find the values of the `offsetHeight` and `offsetWidth` properties. Those numbers are how many pixels tall and wide the button is, including its border and the padding inside the border. If users click the border or padding, that counts as clicking the button, so those properties tell you how large the click target is. The [WCAG SC 2.5.5 standard](https://www.w3.org/WAI/WCAG21/Understanding/target-size.html) recommends that pointing and clicking targets be at least 44 pixels high and wide. This is a level-AAA standard, which means UI creators don&rsquo;t get into trouble by violating it, but following this recommendation can signify that you have made extra effort to make a UI easy for **all** users.
1. So, create a test requiring all buttons to be at least 44 pixels high. The `offsetHeight` property is **not** a style property, so your test should use the `testProperty()` function, not the `testStyle()` function. The value of `offsetHeight` is a **number** (of pixels), not a string. To require the height to be at least 44 pixels, you can use `'offsetHeight'`, `'least'`, and `44` as the arguments of `testProperty()`. The branch should fail this test.
1. Create a similar test for button width. The property is `offsetWidth`. The branch should pass this test if &ldquo;Submit&rdquo; makes the button at least 44 pixels wide.

## <a name="revise"></a>Revise, pass

Now you will make sure that the branch passes all of the new tests, while continuing to pass the earlier tests. After each revision, save the file(s), note the effect on the test results, and if necessary debug.

Caution: Cypress detects file changes and reruns your tests, but it often fails to do this correctly, improperly reporting failures. If you are suspicious of the test results, click the &ldquo;Run all tests&rdquo; button (&#x21bb;) or reload the Cypress test page (`CTL-r`).

1. Make the branch pass your test for a white button text color.
   1. First, open `src/styles.scss`.
   1. Add this ruleset to that file:

      ```scss
      button {
        color: #fff;
      }
      ```

   1. Save the file.
   1. The branch should now pass the test.
1. Make the branch pass the test for a Utopia red button background color. Above or below the `color` declaration, add a declaration setting the `background-color` style to Utopia red. Its Hex and RGB values are given above, and you may use either.
1. Make the branch pass the test for rounded button corners. Do this by adding another declaration to the same ruleset, giving a value to the `border-radius` style. You can give it the value `8px`, to match the test. Even better, however, you can give it a **relative** value, so that the border will keep its shape if the user zooms in or out. The relative unit of measurement is `rem`. The value `1rem` is the size of the document font, which by default is 16 pixels. So you can express 8 pixels as `0.5rem` instead of `8px`, and the branch should pass the test. Try both and verify that either of them makes the branch pass the test.
1. Having rounded corners does not require having a border at all. Add a declaration setting `border` to `'none'`, to make buttons borderless.
1. Make the button tall enough so the branch passes the button-height test. Add another declaration giving a value to the `min-height` style. In the spirit of the WCAG SC 2.5.5 standard, you can set it to `44px` rather than to its `rem` equivalent of `2.75rem`. This will allow buttons to assume a flatter shape if the user enlarges the default font size, but will also keep them usable if the user makes the default font smaller.
1. Add a similar declaration giving the same value to `min-width` style. The branch should now pass all the tests.

## <a name="completion"></a>Completion

Your new tests and revisions have improved the visual appearance of your application, while still ensuring conformity to industry and Utopia standards and best practices.

1. Open the `README-switch.md` file and follow the &ldquo;Completion&rdquo; instructions.

==> tdd-lab.npm/lessons/05/README-05.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 5: Dynamic Styling

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Explore](#explore)
- [Test for focus, fail](#focustest)
- [Test for button hover, fail](#buttontest)
- [Test for label hover, fail](#labeltest)
- [Test for button focus and hover, fail](#dualtest)
- [Revise, pass focus](#revisefocus)
- [Revise, pass button hover](#revisebutton)
- [Revise, pass label hover](#reviselabel)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will use dynamic styling to make the view&rsquo;s appearance vary, depending on data and events.

In Lesson 4 you improved your application&rsquo;s appearance. In the process, you equipped your application with tests for conformity to the application&rsquo;s own visual design and to some industry standards.

But the styles that you applied were static. They did not change in response to user navigation.

When users navigate, they are accustomed to see styles change in industry-standard ways:

- When a user hovers with a mouse over a link or some form controls or form-control labels, the item changes its appearance. This lets mouse users [&ldquo;know if they are hovering over something clickable&rdquo;](https://developers.google.com/web/fundamentals/accessibility/how-to-review#interactive_elements_like_links_and_buttons_should_indicate_their_purpose_and_state). This is especially helpful when a user makes a **control** clickable by hovering over one of its **labels**. Without a hover indicator, the user might click the label without understanding that this will perform an action.
- Putting a link or form control into _focus_ by moving to it with the `TAB` key or clicking an input field also changes its appearance, according to the [WCAG SC 2.4.7](https://www.w3.org/WAI/WCAG21/Understanding/focus-visible.html) accessibility standard.

  - If it is an input field, this change tells the user that any keyboard text now entered will go into that field.
  - If it is a button, the change tells the user that pressing the `ENTER` or `SPACE` key will activate the button.
  - If it is a link, the change tells the user that pressing the `ENTER` key will follow the link to a new location.

In this lesson you will make your application show users clearly where they are hovering and focusing.

There is an industry-standard style to indicate focus: a rectangular outline, usually blue but sometimes gray or black, around the focused element. Browsers automatically provide that, but the browser versions vary and are usually difficult to see. If you define an easy-to-see focus indicator, you make a UI more accessible.

There is no industry-standard style to indicate hovering. In this lesson you will define easily visible hover indicators that do not conflict with your focus indicator.

In Lesson 6 you will return to the content. The content has been static until now, but you will make it deliver requested information to its users.

## <a name="setup"></a>Setup

1. Open the `README-switch.md` file and follow the &ldquo;Setup&rdquo; instructions.

## <a name="explore"></a>Explore

1. In your browser, hover over the phrase &ldquo;Search Form&rdquo;, the word &ldquo;Name&rdquo;, the input field, and the &ldquo;Submit&rdquo; button with your mouse. Note the UI&rsquo;s behavior. The cursor is normally a diagonal arrow. It becomes a text-selection cursor (&ldquo;I-beam&rdquo;) over the heading &ldquo;Search Form: Utopia Crew Search&rdquo; and the input field. It remains unchanged over &ldquo;Name to search for &hellip;&rdquo;; that is because that text is the label of the input field, and clicking it will put the input field into focus. When you hover over the button, nothing changes.
1. With the developer tools closed, press the `TAB` key to put the form controls into focus, one after the other. Notice the thin outline that tells you which control is in focus.

## <a name="focustest"></a>Test for focus, fail

### Preparation

1. In `e2e/src/integration/app.spec.ts`, create a group for dynamic style tests. Put it after the button group and just before the end of the home-view group. You might make the `describe()` function&rsquo;s first argument `'focusable and hoverable elements'`.
1. Begin this group by defining the expected styles for elements in, and not in, focus. Here is an object you can use:

   ```typescript
   const styles = {
     focus: {
       'outline-style': 'solid',
       'outline-offset': /^[1-3](?:\.\d+)?px$/,
       'outline-width': /^[1-3](?:\.\d+)?px$/,
       'outline-color': 'rgb(0, 116, 201)'
     },
     blur: {
       'outline-style': 'none'
     }
   };
   ```

   This constant specifies that elements not in focus have no outline, and elements in focus have outlines that are solid, are [Utopia link blue](http://corpsp.Utopia.com/pnd/mc/Accessibility/SiteAssets/SitePages/Text%20contrast%20minimum/Brand%20Link%20Color%20Studies%20-%20Design%20Leadership%2020181030.pptx), and have thicknesses and offsets from their elements at least 1 pixel and less than 4 pixels. The Hex code for Utopia link blue (the equivalent of `'rgb(0, 116, 201)'`) is `'#0074c9'`.

   Two of these specifications are ranges, expressed as regular expressions. A value of `'1.64px'` or `'2px'` would match, but a value of `'4px'` would not. The reason for specifying a range is that browsers don&rsquo;t render elements with exactly the sizes specified by stylesheets. Your stylesheet could specify `2px` or (equivalently) `0.0125rem`, and yet a browser could render the item at, for example, 1.6 or 2.4 pixels. Testing for a range allows for such inaccuracy.

1. Add this function to the group, to change the focus or hover state of an element:

    ```typescript
    const changeStateOf: (sel: string, ix: number, ch: string) => void = (
      selector,
      index,
      change,
    ) => {
      if (change === 'focus') {
        cy.get(selector).eq(index).focus();
      } else if (change === 'blur') {
        cy.get(selector).eq(index).blur();
      }
    };
    ```

    This function requires a CSS selector, an index, and the string `'focus'` or `'blur'`. It uses the first two arguments to identify an element (for example, `'button'` and 3 would identify the 4th button). It then performs the requested state-change action on the element.

    Each method call in each chain returns an element (or a collection of elements) wrapped in a JQuery object and, in turn, wrapped in a Cypress Chainable object. That is how Cypress ensures that each method waits for the previous one&rsquo;s completion and operates on its result.
  
1. Add this function to the group, to test whether an HTML element, wrapped in a JQuery object, has an expected style:

    ```typescript
    const hasExpectedStyle: (
      el: JQuery<HTMLElement>,
      sk: string,
      sv: string | RegExp,
    ) => void = ($element, styleKey, styleVal) => {
      if (typeof styleVal === 'string') {
        expect($element).css(styleKey, styleVal);
      } else {
        expect($element).css(styleKey).match(styleVal);
      }
    };
    ```

   This function asks for an HTML element wrapped in a JQuery object, the name of a style, and the expected value of that style property of the element. In the `styles` object, there are string values and regular-expression values. The function figures out which type of value the value is and then applies the appropriate type of comparison.
1. Add this function to the group, to test whether an element has its expected styles:

    ```typescript
    const testStylesOf: (sel: string, ix: number, so: object) => void = (
      selector,
      index,
      styleObj,
    ) => {
      cy.get(selector)
        .eq(index)
        .then(($element) => {
          Object.keys(styleObj).forEach((styleKey) => {
            hasExpectedStyle($element, styleKey, styleObj[styleKey]);
          });
        });
    };
    ```

   This function asks you for a CSS selector and an index, like `changeStateOf()`. It also requires a style object, such as `styles.focus` or `styles.out.label`. The `get()` and `eq()` methods yield an HTML element wrapped in a JQuery object and in turn wrapped in a Cypress Chainable object. But the `then()` method unwraps that and yields a JQuery-wrapped HTML element. For each of the style specifications in the object, the function identifies the expected value and calls the `hasExpectedStyle()` function to test for it.

### Testing

1. The above shared code makes it easy to perform tests for focus styles, and they will likewise simplify testing for hover styles later. Start with this test:

    ```typescript
    it('query field should not be outlined if not in focus', () => {
      testStylesOf('#query', 0, styles.blur);
    });
    ```

   The branch should pass this test, since by default a search input has no outline. It has a **border**, but an outline is different from a border.

   The selector in this test, `'#query'`, makes use of the `id` attribute of the `input` element. If it had no `id` attribute, an `'input'` selector would perform the same, since this is the first (and currently the only) `input` element.

1. Add this test requiring the same element to be outlined if it **is** in focus:

    ```typescript
    it('query field should be outlined if in focus', () => {
      changeStateOf('#query', 0, 'focus');
      testStylesOf('#query', 0, styles.focus);
    });
    ```

   The branch should fail this test.

1. Add a third test for the same element if it is put **into** focus and then put **out** of focus again. The branch should pass this test.
1. You have created three tests for the focus styles of the query field. The button, too, can be focused, so make a copy of those three tests and edit them so the new tests apply to the button. The branch should, as with the input focus tests, pass the first and third but fail the second of these tests.

## <a name="buttontest"></a>Test for button hover, fail

### Preparation

1. The `styles` object has two properties: `focus` and `blur`. Add two more properties to it: `over` (being hovered over) and `out` (not being hovered over), as follows:

   ```typescript
   over: {
     button: {
       color: 'rgb(0, 0, 0)',
       'background-color': 'rgb(255, 255, 255)',
       'border-width': /^[1-2](?:\.\d+)?px$/,
       'border-style': 'solid',
       'border-color': 'rgb(0, 0, 0)'
     }
   },
   out: {
     button: {
       color: 'rgb(255, 255, 255)',
       'background-color': 'rgb(150, 21, 29)',
       'border-style': 'none',
     }
   }
   ```

   These two properties each have a `button` subproperty, because hover styles will vary among element types. These properties specify white text on Utopia red when a button is not being hovered over, and black text on white with a solid black border when it is being hovered over.

1. The `changeStateOf()` function deals with focus changes, but not yet with hover changes. Add two more `else if` conditions to it:

    ```typescript
    } else if (change === 'over') {
      cy.get(selector).eq(index).trigger('mouseenter');
    } else if (change === 'out') {
      cy.get(selector).eq(index).trigger('mouseleave');
    }
    ```
  
### Testing

1. Copy your three tests for the focus styles of the button and revise them to test hover styles. Note that the style objects will need three segments to reference them, such as `styles.out.button`. The branch should pass the first and third, and fail the second, of these tests.

## <a name="labeltest"></a>Test for label and input hover, fail

### Preparation

The home view contains a search input field with a label. By default the cursor changes from an arrow to a selection symbol when a user hovers over ordinary text, but not when the user hovers over the label of an input. If the user notices that difference, the user can infer that clicking the label will put the input field into focus. That is a very subtle hover indicator; you will create one that is much easier to see.

Your hover indicator for labels will **not** apply to the inputs that they label. Here is why: Users often move the mouse while editing in an input field. Random movement could make a hover indicator flash on and off. That would be disruptive. So you will let the browser apply its default hover style to the input, changing only the cursor.

1. The `styles.over` and `styles.out` objects specify hover styles for buttons but not for labels or inputs. Add `label` and `input` subproperties to them, as follows:

   ```typescript
   over: {
     label: {
       color: 'rgb(255, 255, 255)',
       'background-color': 'rgb(0, 0, 0)'
     },
     input: {
       color: 'rgb(0, 0, 0)',
       'background-color': 'rgb(255, 255, 255)',
     }
   },
   out: {
     label: {
       color: 'rgb(0, 0, 0)',
       'background-color': 'rgba(0, 0, 0, 0)',
     },
     input: {
       color: 'rgb(0, 0, 0)',
       'background-color': 'rgb(255, 255, 255)',
     }
   }
   ```

   The `out.label` properties specify black text and an inherited background color. This is because text in a browser normally doesn&rsquo;t bring a background color with it. The specification `rgba(0, 0, 0, 0)` means a black color (`rgb(0, 0, 0)`) with 0 opacity (i.e. 100% transparency). This is how the `getComputedStyles()` method reports an element not having its own background color, and therefore inheriting its parent&rsquo;s background color.

   The `over.label` properties specify white text on black.

   The `over.input` and `out.input` properties specify black text on white. Unlike ordinary text, an input field by default has a white background, regardless of its parent&rsquo;s background color. It does **not** inherit a background color.

### Testing

1. Copy your three tests for the hover styles of the button and revise them to test for the label. The branch should pass the first and third, and fail the second, of these tests.

1. Copy those tests and revise them to test for the input. The branch should pass all of these tests.

## <a name="dualtest"></a>Test for button focus plus hover, fail

1. In your current UI, the only element that should display both a focus indicator and a hover indicator is the button. When you put it into focus and also hover over it, it should display both indicators at the same time. Add a test to `app.spec.ts` that puts the button into focus, then hovers over it, then tests it for focus styles, and finally tests it for hover styles. The branch should fail this test.
1. Add a similar test, except that it hovers over the button before putting it into focus, instead of after. The branch should fail this test, too.

## <a name="revisefocus"></a>Revise, pass focus

1. Make the branch pass your tests for focus styles. You can do this most easily by adding rulesets to the `src/styles.scss` file. These rulesets should satisfy your tests:

   ```scss
   *:focus {
     outline-width: 0.15rem;
     outline-offset: 0.15rem;
     outline-style: solid;
     outline-color: #0074c9;
   }
   *:not(:focus) {
     outline: none;
   }
   ```

   After you save the `styles.scss` file, Cypress may show passing results for all your focus tests, but you will probably need to activate its &ldquo;Run all tests&rdquo; button to resynchronize it.

## <a name="revisebutton"></a>Revise, pass button hover

It might seem that making the branch pass your button hover tests is just as easy as making it pass the focus tests, but that is not true. Cypress performs focus actions with `focus()` and `blur()`, but performs hover actions with `trigger('mouseenter')` and `trigger('mouseleave')`. Electron responds properly to `focus()` and `blur()`, including respecting the CSS `:focus` pseudo-class. But Electron does not respond to `trigger()`. It dispatches the named event, but does nothing else. So, if you tried to use the CSS `:hover` pseudo-class to make an element&rsquo;s styles depend on whether it is being hovered over, your technique would work in an ordinary browser, but Cypress would not recognize that success. The developers of Cypress have been [discussing this limitation](https://github.com/cypress-io/cypress/issues/10) for a few years, but it is complex.

To make the branch pass the hover tests, you can use JavaScript to detect hover states and respond to them by changing the values of elements&rsquo; `classList` properties. A CSS stylesheet can contain rulesets with class selectors, making the elements&rsquo; styles change in response to changes in hover states. Electron will reflect those changes.

Without a front-end framework, you could do this with a `script` element in your HTML document, referencing a script calling the `addEventListener()` method to create listeners for `mouseenter` and `mouseleave` events on an element.

With Angular, you can do this more compactly by adding event-binding attributes to elements in your HTML template.

1. In `app.component.html`, give the `button` element an Angular _template reference variable_ (i.e. a name) by adding the bare attribute `#submit` to it.
1. Add this event-binding attribute to the `button` element:

   ```angular2html
   (mouseenter)="submit.classList.add('over')"
   ```

   The `()` is event-binding syntax. It means: When a `mouseenter` event occurs on this element, execute the template expression (the quoted code). This template expression begins with `submit`, a reference to the button, using the template reference variable you gave it. It then adds `'over'` to the classes of the button.
1. Add a similar event-binding attribute to the element, for the `mouseleave` event. The method to be executed is `remove` rather than `add`. As a result of these attributes, the `button` element will have the class `over` when it is being hovered over, and it will not have that class when it is not being hovered over.
1. To make the presence and absence of the `over` class change the styles of the `button` element, add these rulesets to `src/styles.scss`:

   ```scss
   button:not(.over) {
     border: none;
     color: #fff;
     background-color: #96151d;
   }
   button.over {
     border-style: solid;
     border-width: 0.1rem;
     border-color: #000;
     color: #000;
     background-color: #fff;
   }
   ```

   When you save the template and the stylesheet, both Chrome and Electron should behave correctly in response to hovering over the button. Check that. Once Cypress is synchronized, the branch should also pass your button hover tests.

## <a name="reviselabel"></a>Revise, pass label hover

1. Add a template reference variable, `#queryLabel`, to the `label` element.
1. Add two event-binding attributes for hover events to that element, similar to the ones you added to the `button` element.
1. In `styles.scss`, add two rulesets for `label` elements with and without the `over` class, similar to those that you added for `button` elements, but specifying black on transparent normally and white on black when being hovered over. The safest way to represent transparency is `rgba(0, 0, 0, 0)`. No declarations are necessary for a border. After you save this file and Cypress is resynchronized, the branch should pass all tests.

## <a name="completion"></a>Completion

Your new tests and revisions have given the application better conformity to Utopia and industry style standards by helping users know where they are focused and hovering. In the next lesson you will use Angular&rsquo;s dynamic content mechanisms to make the application do real work.

1. Open the `README-switch.md` file and follow the &ldquo;Completion&rdquo; instructions.

==> tdd-lab.npm/lessons/06/names.ts <==
export const names = [
];

==> tdd-lab.npm/lessons/06/README-06.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 6: Dynamic Content

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Test preparation](#prep)
- [Test, fail](#test)
- [Revise, pass](#revise)
- [Practice](#practice)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will use dynamic content mechanisms to make your application accept user queries and display requested information.

In Lesson 5 you made form controls in your application change styles in response to keyboard and mouse actions, thereby revealing their states clearly to a user in fulfillment of industry standards. The result was an interface that better helps a wide range of users (including users with disabilities) successfully interact with the form.

However, the application still doesn&rsquo;t do anything useful. In this lesson you will make it begin to serve its purpose: displaying information about a Utopia crew member in response to a search query.

Your application already has some dynamic content, which you can see in `app.component.html`, including:

- an interpolated view name in the `h1` heading (`{{ title }}`)
- event bindings that produce style changes when users initiate `mouseenter` and `mouseleave` events

The next dynamic content to be added is the results of a search. The results could be a message informing the user that nobody matching the query was found, or could be a list of the names matching the query.

But what constitutes a search? In a form like this, it is a standard browser behavior to recognize a form submission when any of these user actions occurs:

- clicking the &ldquo;Submit&rdquo; button
- pressing the `ENTER` key when the button is in focus
- press the `SPACE` key when the button is in focus
- pressing the `ENTER` key when the query field is in focus

In this lesson you will make your application perform searches when users request them in any of these ways. Under the search form, the application will display a summary telling the user what happened and, if there were any matches, a list of the matching names. The list should be coded as a `ul` (bulleted) or `ol` (numbered) list, with each name an `li` element, in accord with the [WCAG SC 1.3.1](https://www.w3.org/WAI/WCAG21/Understanding/info-and-relationships.html) standard, which, in essence, says that the code should agree with the &ldquo;information, structure, and relationships&rdquo; of the UI.

You will make your application get names from Utopia&rsquo;s Crewfinder service in a later lesson. In this lesson the application will draw on a fixed sample of names, located in the `lessons/06/names.ts` file. You will be able to base your tests for correct search results on the fact that the searching will be limited to those names.

In order to ensure that users are aware of any changes that appear below the form, your application will enclose the changing content in a _status_ landmark. Assistive technologies will alert users to changes within that region. This technique is especially useful to vision-impaired users. It conforms to a [W3C recommendation](https://www.w3.org/WAI/perspective-videos/notifications/) and the [WCAG SC 4.1.3](https://www.w3.org/WAI/WCAG21/Understanding/status-messages.html) standard.

A [`section` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section) is appropriate as the status landmark containing the search results. To let the user know what kind of information will appear there, the `section` element will have a heading with the text &ldquo;Search result&rdquo;. Since the view already has an `h1` heading, this one will be an `h2` heading.

Because Jest&rsquo;s Jsdom browser emulator does not apply stylesheets, your style tests used Cypress. Tests for the content of the search results will not require the application of stylesheets, but they **will** require the processing of form submissions. Jsdom, similarly, does not process form submissions. Therefore, your tests for search results, too, must use Cypress.

## <a name="setup"></a>Setup

1. Open the `README-switch.md` file and follow the &ldquo;Setup&rdquo; instructions.

## <a name="prep"></a>Test preparation

1. In `app.spec.ts`, just before the closing line of the &ldquo;home view&rdquo; test group, create a group for tests of search results.
1. For use in this group&rsquo;s tests, define a constant specifying the three possible summaries in the result section:

   ```typescript
   const summaries = {
     initial: '',
     noMatches: 'No matches',
     yesMatches: 'Matching names'
   };
   ```

1. Then define a function to enter a query into the query field:

   ```typescript
   const setQuery: (q: string) => void = query => {
     if (query.length) {
       cy.get('#query')
         .clear()
         .type(query);
     } else {
       cy.get('#query').clear();
     }
   };
   ```

   This uses the Cypress `clear()` method to empty the field and then, if the query isn&rsquo;t blank, the `type()` method to enter a string into it. (The `cy.type()` method requires a non-blank argument, so you can&rsquo;t simplify this function by using `type()` in all cases.)
1. Define another function to submit the form:

   ```typescript
   const submitForm: () => void = () => {
     cy.get('form')
       .first()
       .submit();
   };
   ```

   As stated in the introduction, users have four different ways to submit the form. You could test for all of these methods. But there is a good argument against that: It is the browser&rsquo;s job to convert these four actions into a form submission, and it is your job to test your application, not to test the browser. In accord with this thinking, you will test your application&rsquo;s response to a form submission, but you will rely on the browser to execute the submission when it should do so.
1. Define a function to check the result summary:

   ```typescript
   const checkSummary: (t: string) => void = type => {
     cy.get('#summary').then($summary => {
       expect($summary.text().trim()).equal(summaries[type]);
     });
   };
   ```

   This test looks for an element with an `id="summary"` attribute and then compares the text content of that element with one of the predefined summaries, depending on whether you call the function with `'initial'`, `'noMatches'`, or `'yesMatches'` as its argument.
1. Add this function to check the list of matching names:

   ```typescript
   const checkNames: (
     m: number,
     f: number,
     y: string[],
     n: string[]
   ) => void = (moreThan, fewerThan, yesStrings, noStrings) => {
     cy.get('form + section[role=status] > ul')
       .first()
       .then($ul => {
         const shownNames = Array.from($ul.find('li')).map(
           li => li.textContent
         );
         const nameCount = shownNames.length;
         expect(nameCount).greaterThan(moreThan);
         expect(nameCount).lessThan(fewerThan);
         yesStrings.forEach(yesString => {
           expect(shownNames.some(name => name.includes(yesString))).equal(
             true
           );
         });
         noStrings.forEach(noString => {
           expect(shownNames.every(name => !name.includes(noString))).equal(
             true
           );
         });
       });
   };
   ```

   This test requires four arguments answering these questions:

   - There should be more than how many names?
   - There should be fewer than how many names?
   - The names should include which strings?
   - The names should fail to include which strings?

   The test assumes that your application will display a bulleted (`ul`), not a numbered (`ol`), list of the matching names. The test finds the `ul` element inside the `status` section and identifies an array of the names listed in it. Then it tests whether the array size is within the specified range and tests each string in both arguments. If the array size is too small or too large, or if any string fails the test, the Cypress Command Log will show you what failed.

## <a name="test"></a>Test, fail

1. Before you create Cypress tests for the search result, add a Jest test requiring the containers for the search result to exist in the template. You can use the test for header and main landmark elements as an example. For this case the selector can be `main > form + section[role=status] > h2 + p#summary + ul`. This says that:

    - The `main` element must have consecutive `form` and `section` children.
    - The `section` element must have a `role` attribute with a `"status"` value.
    - The `section` element must have consecutive `h2`, `p`, and `ul` children.
    - The `p` element must have an `id` attribute with a `"summary"` value.

1. Add this Jest test requiring the `h2` heading to have the text content `Search result`:

    ```typescript
    it('h2 should have the text Search result', () => {
      const resultHeading = compiled.querySelector(
        'main > form + section[role=status] > h2'
      );
      expect(
        resultHeading && resultHeading.textContent.trim()
      ).toBe('Search result');
    });
    ```

1. The resources that you have added to the Cypress group will make it easier to create tests. Begin with this Cypress test for the condition in which no query has been submitted:

   ```typescript
   it('should be initially empty', () => {
     checkSummary('initial');
     checkNames(-1, 1, [], ['Rom', 'ong', 'x']);
   });
   ```

   The branch should fail this test, and all later tests in this group, because the result section doesn&rsquo;t exist yet.
1. Inspect the `names.ts` file. The names in it will constrain the tests you write. Notice that one name has (arbitrarily) been duplicated, to reflect the fact that Utopia crew names are not unique. This could protect you from creating an implementation that depends on the names being unique.
1. Next, add this test for a form submission:

   ```typescript
   it('should show correct results', () => {
     setQuery('xyzabc123');
     submitForm();
     checkSummary('noMatches');
     checkNames(-1, 1, [], ['Rom', 'ong']);
   });
   ```

   This test submits a query that will not match any name.
1. Add four more statements (`setQuery()` etc.) to the same test, for a **partially** matching query, such as `'u'`. Set appropriate arguments to `checkSummary()` and `checkNames()`.
1. Add four more statements for an **empty** submission (with `''` as the argument to `setQuery()`).
1. If you wish, add more statements with different queries.

## <a name="revise"></a>Revise, pass

1. Make the branch pass your test for an initially empty result section. To do this, add an empty `section` element to the template after the `form` element, with a `role` attribute whose value is `"status"`. Add three more elements inside the `section` element:
   1. an `h2` element, with text content `Search result`
   1. a `p` element, with an `id="summary"` attribute
   1. a `ul` element after the `p` element
1. To make the branch pass the remaining tests, you need more features in the root component. One is the list of names. Since it will be used in multiple lessons, copy it from the `lessons/06` directory of this (`tdd-lab.npm`) repository to the `src/assets` directory in the `crewinfo` repository. You can do this in your code editor, or in your bash shell with this command:

   ```bash
   cp ../tdd-lab.npm/lessons/06/names.ts src/assets
   ```

   This command assumes that both repositories are in the same directory.

1. In `app.component.ts`, add this statement to the `import` statements at the top:

   ```typescript
   import { names } from '../assets/names';
   ```

   Now the sample of crew members&rsquo; names will be available for use in a function that produces the search result.
1. Insert these statements declaring and initializing additional members of the `AppComponent` class:

   ```typescript
   summary = '';
   resultNames: string[] = [];
   ```

   You will cause these variables to have the correct values assigned to them. The template will be able to use them to populate the search result in the view.
1. Add this function to the `AppComponent` class to assign values to those variables:

   ```typescript
   handleFormSubmission: (e: Event, q: string) => void = (event, query) => {
     event.preventDefault();
     const yesSummary = 'Matching names';
     const noSummary = 'No matches';
     if (query.length) {
       const lowerCaseQuery = query.toLowerCase();
       this.resultNames = names.filter(name =>
         name.toLowerCase().includes(lowerCaseQuery)
       );
       this.summary = this.resultNames.length ? yesSummary : noSummary;
     } else {
       this.resultNames = names;
       this.summary = yesSummary;
     }
   };
   ```

   This function requires two arguments: a form-submission event and a query string. The function prevents the browser from performing its default response to the event; that stops the browser from reloading the page. Then it checks the length of the query. If the query is at least 1 character long, the function performs case-insensitive matching; otherwise it treats **all** the names as matched. It finally updates `resultNames` and `summary`.
1. Now revise the template (`app.component.html`) to make use of the resources that you have added to the root component. First, give the summary element a property-binding attribute:

   ```angular2html
   [textContent]="summary"
   ```

   This will automatically update the text content of the element to equal the current value of the `summary` member of `AppComponent`.
1. Insert an `li` element into the `ul` element.
1. Give the `li` element the structural-directive attribute

   ```angular2html
   *ngFor="let name of resultNames"
   ```

1. Insert `{{ name }}` as the content of the `li` element.

   This mechanism iterates through the `resultNames` array and, on each iteration, creates an `li` element in that location and interpolates the current item of `resultNames` into it as its text content. Even though the template contains only one `li` element, the rendered HTML document will contain as many of them as there are names to display (0 if none).

1. Whenever the form is submitted, you want `handleFormSubmission()` to be executed. It will need the query string as its second argument. To enable this, add a template reference variable `#query` to the query `input` element.
1. Add this event-binding attribute to the `form` element:

   ```angular2html
   (submit)="handleFormSubmission($event, query.value)"
   ```

   Any of the four mechanisms of form submission should trigger a `submit` event on the `form` element. When that event is fired, the quoted template expression will be executed. The submission event and the query string (the value of the query `input` element, referenced by its template reference variable `query`) will be passed to the `handleFormSubmission()` function.

   Those changes to the root component and the template should make the branch pass all of the tests.

1. Confirm your solution by performing various searches in your browser. Verify that searching works correctly with:
   - a button click
   - a button focus and `ENTER`
   - a button focus and `SPACE`
   - a query input focus and `ENTER`

## <a name="practice"></a>Practice

1. Your template uses Angular&rsquo;s interpolation syntax to display the view heading. The property-binding attribute syntax can do the same job. To demonstrate this, delete `{{ title }}` and instead give the `h1` element a property-binding attribute that assigns the value of the `title` member of the `AppComponent` class to the `textContent` property. The branch should continue to pass all the tests.

## <a name="completion"></a>Completion

Your new tests and revisions have made the application perform a search function. In the next lesson you will make the output of searches change dynamically **while** a user enters a query, not only **after** the user submits the query. You will also give the user a choice among search modes.

1. Open the `README-switch.md` file and follow the &ldquo;Completion&rdquo; instructions.

==> tdd-lab.npm/lessons/07/README-07.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 7: Dynamic Forms

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Test for search-mode options, fail](#mode)
- [Test for search result, fail](#result)
- [Revise, pass](#revise)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will add options and dynamic output to a form.

In Lesson 6 you implemented a working form. Its submission produced output based on a query entered by a user into an input field.

In this lesson you will improve the form&rsquo;s behavior. Currently your form gives the user no choice about where in the names to search. All searches compare the user&rsquo;s query string with the full name (after both are lower-cased). In addition, your application does nothing while the user is entering a string into the text field. The application waits until the user submits the form. Only then does it respond by showing all matching names.

You will improve both of these behaviors:

- The application will let the user search more precisely. If the user wants to enter part (or all) of of a crew member&rsquo;s **given** name (sometimes called &ldquo;first name&rdquo; or &ldquo;forename&rdquo;), or of a **family** name (&ldquo;last name&rdquo;, &ldquo;surname&rdquo;), the application will be able to limit the matching accordingly.
- The application will let the user know how many names match the text entered so far. For example, if the user intends to enter &ldquo;Argfloxos&rdquo; but the match count reaches 0 when the user has entered &ldquo;Argf&rdquo;, the user will be able to avoid wasting time entering &ldquo;loxos&rdquo;.

The plan for this lesson is to:

1. add tests for a search-mode-options feature
1. add tests for a dynamic-match-count feature
1. implement the new features so that the branch passes all tests

The improved application will include:

- radio buttons with which the user can choose a search mode
- a search-output summary that reports the current match count

There will be three search modes (whole-name, given-name, and family-name), so there will be three radio buttons.

In accord with industry standards, they will be:

- grouped: The group will include instructions on how to use the radio buttons.
- labeled: All users (including users with disabilities who rely on assistive technologies) will be informed about the purpose of each radio button.
- mutually exclusive: No more than one radio button can be checked.

The standard way to group form controls is to include them in a `fieldset` element and make the first child of that element a `legend` element containing the instructions for the entire group. See the [WCAG H71](https://www.w3.org/WAI/WCAG21/Techniques/html/H71) accessibility standard for details.

The whole-name radio button will be checked by default. It will require a user action to change the search mode to family-name or given-name.

The application will ensure that the displayed summary shows the count of matching names and is always consistent with the user&rsquo;s current choices.

The application will display a list of matching names whenever the user submits the form. If after that the user changes either the query or the search mode, the name list will disappear.

## <a name="setup"></a>Setup

1. Open the `README-switch.md` file and follow the &ldquo;Setup&rdquo; instructions.

## <a name="mode"></a>Test for search-mode options, fail

1. Radio buttons are `input` elements, with `type="radio"` attributes. Your existing Jest tests for inputs will cover radio buttons, too, but they leave some gaps. Fill in one gap by revising the Jest test for elements belonging to forms, making it include `fieldset` elements, too. The branch should continue to pass the revised test, because there is no `fieldset` element yet.
1. A `fieldset` element can contain a `legend` element as its first child, so as to provide instructions for using the controls in the `fieldset` element. Your home view will contain one `fieldset` element containing the radio buttons for choosing a search mode. Add a test requiring a `fieldset` element containing a `legend` element with `'Where to search'` as its text content. This test will accomplish that:

   ```typescript
   it('should contain a fieldset with a search-mode legend', () => {
     const legend: HTMLLegendElement = compiled.querySelector(
       'fieldset > legend:nth-child(1)'
     );
     expect(legend && legend.textContent.trim()).toBe('Where to search');
   });
   ```

   Since there is no `fieldset` element in the view yet, the branch should fail this test.
1. Add a test requiring all radio buttons to be enclosed in `fieldset` elements. You can do this by comparing the collection of all radio buttons with the collection of all radio buttons inside `fieldset` elements. They should be identical. Here is code for that test:

   ```typescript
   it('all radio buttons should belong to fieldsets', () => {
     const fieldSetRadioButtons: HTMLInputElement[] = Array.from(
       compiled.querySelectorAll('fieldset input[type=radio]')
     );
     const radioButtons: HTMLInputElement[] = Array.from(
       compiled.querySelectorAll('input[type=radio]')
     );
     expect(fieldSetRadioButtons).toEqual(radioButtons);
   });
   ```

   The branch should pass this test, because there are no radio buttons yet.
1. Radio buttons are mutually exclusive when they have `name` attributes that all have the same value. Add this test requiring that all the radio buttons share a `name` value:

    ```typescript
    it('all radio buttons should have the same name', () => {
      const radioButtons: HTMLInputElement[] = Array.from(
        compiled.querySelectorAll('input[type=radio]')
      );
      expect(
       radioButtons
       .slice(1)
      .every(
        radioButton =>
          radioButton.name && radioButton.name === radioButtons[0].name
      )
     ).toBeTruthy();
   });
   ```

   This test checks whether each radio button after the first one has a `name` attribute with a non-blank value that is the same as that of the first radio button. Since there are currently no radio buttons, the branch should pass this test.
1. You have a Jest test requiring the existing `input` element to be thoroughly labeled. Create another test imposing a similar requirement on the three radio-button `input` elements. You can adapt the existing test as follows:

   ```typescript
   it('search-mode radio buttons should be clearly labeled', () => {
     const labels: string[] = [
       'whole names (format: Familyname,Givenname)',
       'family names',
       'given names'
     ];
     const modeInputs: HTMLInputElement[] = Array.from(
       compiled.querySelectorAll('input[type=radio]')
     );
     [0, 1, 2].forEach(index => {
       expect(
         modeInputs[index] &&
           modeInputs[index].labels.length &&
           modeInputs[index].labels.item(0).textContent.trim()
       ).toBe(labels[index]);
     });
   });
   ```

   The branch should fail this test when it cannot find any of the radio buttons.
1. Add this test to require the first radio button to be initially checked:

    ```typescript
    it('first radio button should initially be checked', () => {
      expect(
        compiled.querySelector('input[type=radio]').checked
      ).toBeTruthy();
    });
    ```

1. Testing radio-button styles, like other styles, requires Cypress. You have already created three Cypress tests for the focus styles of the query `input` element. Now you will have three more `input` elements, and they should exhibit the same focus styles. Therefore, generalize those three tests to cover all `input` elements at once. You can generalize the first test by revising it to:

   ```typescript
   it('inputs should not be outlined if not in focus', () => {
     [0, 1, 2, 3].forEach(index => {
       testStylesOf('input', index, styles.blur);
     });
   });
   ```

   Since there are no radio buttons yet, the branch should fail this test (and the next two tests) when Cypress tries to find the second `input` element.
1. Revise the second test for input focus styles similarly.
1. Revise the third test for input focus styles similarly.
1. Similarly, you have already created three tests for the hover styles of labels of the query `input` element, but radio-button `input` elements, too, will have labels, and their hover styles should be the same. So revise those three tests, as you did for the focus-style tests. The branch should fail these tests when Cypress fails to find more than one label.
1. Your tests for input hover styles apply to the input with the `id="query"` attribute. You could extend them to the planned radio-button inputs, but browsers display radio buttons the same without regard to style properties, so it is reasonable to leave these tests unchanged.

## <a name="result"></a>Test for search result, fail

1. In the search-result group in `app.spec.ts`, you have a `setQuery()` function. Now tests will need to be able to set the search mode, too. Add this function to the group:

   ```typescript
   const setMode: (i: number) => void = index => {
     cy.get('input[type=radio]')
       .eq(index)
       .check();
   };
   ```

   This function takes a numeric argument, with `0` represting `whole`, `1` representing `family`, or `2` representing `given` mode. It checks (i.e. selects) the corresponding radio button.
1. You have been using a constant, `summaries`, to check whether the summary is correct. In this lesson the summary will vary, depending on how many names the current query matches. For example, if there are 13 matching names, the summary will be &ldquo;Matching name count: 13&rdquo;. Delete the constant, since it is obsolete.
1. In this lesson you can know exactly how many names should match each possible query. But in a later lesson your application will perform queries on a list of more than 20,000 names of people at Utopia, and the names can change as crew members join and leave. So you will then want to require that the match count fall into a range, thereby keeping your tests resilient. With this goal in mind, revise the `checkSummary()` function as follows to require the match count at the end of the summary to fall into a specified range:

    ```typescript
    const checkSummary: (g: number, l: number) => void = (
      greaterThan,
      lessThan
    ) => {
      cy.get('#summary').then($summary => {
        const summaryText = $summary.text().trim();
        const count = Number.parseInt(summaryText.replace(/^.+: /, ''));
        expect(count).greaterThan(greaterThan);
        expect(count).lessThan(lessThan);
      });
    };
    ```

   The arguments to this function are the exclusive lower and upper limits of the range. If you know that the match count will be 0, you can provide the arguments `-1` and `1`.
1. The test for the initial (pre-action) search result, requiring it to be empty, will not apply any longer. The initial result will contain only a summary, showing the total count of names. You can test for that as part of the following test. So delete this test.
1. Revise the test for search results to manipulate **both** the search mode **and** the query, while also using the new version of `checkSummary()`. Here is a start for the new test (you may change the strings if you wish):

    ```typescript
    it('should show correct results', () => {
      checkSummary(19, 21);
      checkNames(-1, 1, [], ['Rom', 'ong', 'x']);
      setMode(1);
      checkSummary(19, 21);
      checkNames(-1, 1, [], ['sm', 'Ar']);
      setQuery('xyzabc123');
      checkSummary(-1, 1);
      checkNames(-1, 1, [], ['n', 'Xu']);
    ```

   Add these additional manipulations to this beginning, checking the summary and names after each manipulation:

   1. Set the mode to `given`.
   1. Set the query to `'u'`,
   1. Submit the form.
   1. Set the mode to `whole`.

   The branch should fail this test, because the summary will differ from what is expected.

## <a name="revise"></a>Revise, pass

1. Make the branch pass your Jest test for a `legend` element by adding a `fieldset` element to the template immediately after the opening tag of the `form` element and then a `legend` element inside the `fieldset` element, with `Where to search` as its text content. The branch should now pass the `legend` test.
1. Add three radio buttons to the template, after the `legend` element and inside the `fieldset` element. Each one should be in a `p` element. A radio button is an `input` element with `type="radio"`. An `input` element has only one tag. Adding these elements should make the branch continue to pass the radio-button location test, but also make it begin to fail the tests for a radio-button name.
1. Make the branch pass the radio-button name test by giving each radio button&rsquo;s `input` element a `name` attribute with the same value, such as `"searchMode"`. Diffentiate them by giving each a `value` attribute, with three different values, such as `"whole"`, `"family"`, and `"given"`.
1. Make the branch pass the radio-button label test, by giving each radio button an implicit label. Inside the `p` element, surround the `input` element with a `label` element. Then, after the `input` element and before the closing tag of the `label` element, insert the text of the label that your test expects the radio button to have. Now the branch should pass all the Jest tests.
1. The query input field&rsquo;s label has a template reference variable (`#queryLabel`) and two event-binding attributes so that it passes the hover-style tests. Give similar attributes to the radio-button `label` elements (such as `#wholeLabel`) to make them, too, pass those tests.
1. The branch should be failing the search-result tests, because the `handleFormSubmission()` function in `app.component.ts` still displays the original search-result summaries and recognizes only the whole-name search mode. With multiple modes and dynamic summary updating, that function requires revision. First, add some variables as `AppComponent` class members to store current values:

    ```typescript
    allNames = names;
    query = '';
    mode = 'whole';
    matchingNames: string[] = this.allNames;
    ```

1. Add this function to derive a summary from the current array of matching names:

    ```typescript
    getSummary: () => string =
      () => `Matching name count: ${this.matchingNames.length}`;
    ```

1. Add two more variables for the parts of the result:

    ```typescript
    summary = this.getSummary();
    resultNames: string[] = [];
    ```

    These statements give the variables their initial values when the view loads (a summary giving the count of all the names, and an empty array of names, because initially no names are displayed). User actions will cause functions to be executed that make use of, and modify, those values.

1. Add a function that, for any name of a crew member, returns the string that a query will be matched against, given the current search mode. Here is the code for that function:

    ```typescript
    modeNameOf: (n: string) => string = (name) => {
      if (this.mode === 'whole') {
        return name.toLowerCase();
      } else if (this.mode === 'family') {
        return name.replace(/,.*/, '').toLowerCase();
      } else if (this.mode === 'given') {
        return name.replace(/^.*,/, '').toLowerCase();
      } else {
        return '';
      }
    };
    ```

    The function gets a name as an argument. It looks up the search mode from the class&rsquo;s `mode` member. Depending on the search mode, it returns the entire name, the part before the comma, or the part after the comma, with any upper-case letters converted to lower case. This function will simplify the computation of the search result.
1. Add this function that returns an array of the names that match the current query, given the current search mode:

    ```typescript
    getMatchingNames: () => string[] = () => {
      if (this.query.length) {
        const lowerCaseQuery = this.query.toLowerCase();
        return names.filter(name =>
          this.modeNameOf(name).includes(lowerCaseQuery),
        );
      } else {
        return this.allNames;
      }
    };
    ```

    In accord with the instructions to the user, if the query is empty the function returns all the names. Otherwise it returns the names that match the query, after the names are made to conform to the search mode and both the names and the query are lower-cased.

1. Replace the previous single handler function with functions to handle the three actions that the user can now take. First, when the user changes the query or changes the search mode, the last three variables that you added above need to be updated. Add a function to do this:

    ```typescript
    handleChange: () => void = () => {
      this.matchingNames = this.getMatchingNames();
      this.summary = this.getSummary();
      this.resultNames = [];
    };
    ```

    This function empties the `resultNames` array, because any display of matching names disappears when the user changes either the query or the search mode.
1. When the user changes the query, the application must assign the new query to the `query` variable and perform the `handleChange()` operations. So, add this function:

    ```typescript
    handleQueryChange: (q: string) => void = query => {
      this.query = query;
      this.handleChange();
    };
    ```

1. Similarly, when the user changes the search mode, the application must assign the new mode to the `mode` variable and perform the `handleChange()` operations. So, add a similar function named `handleModeChange()`.

1. Finally, when the user submits the form, the application must display the matching names for the existing query and search mode. Therefore, replace the `handleFormSubmission()` function with this much simpler revision:

   ```typescript
   handleFormSubmission: (e: Event) => void = event => {
     event.preventDefault();
     this.resultNames = this.matchingNames;
   };
   ```

1. The newly added functions are not called yet when the user acts. A change of the query must call the `handleQueryChange()` function. To make this happen, add an event-binding attribute to the query `input` element in the template. The event is `input`, and the template expression is `"handleQueryChange(query.value)"`. The `input` event is triggered whenever the user changes the entered value.
1. Similarly, any change of the search mode must call the `handleModeChange()` function. To make this happen, add an event-binding attribute to each radio button&rsquo;s `input` element. For example, the attribute for the first radio button is `(change)="handleModeChange('whole')"`.
1. Checking a radio button dispatches a `change` event on that radio button. After these attributes are added, the branch should pass all Cypress tests, while continuing to pass all Jest tests. That should confirm that duplicate names are shown and counted when queries match them.
1. The original `handleFormSubmission()` function required two arguments, but now it requires only an event argument, so revise its signature in the event-binding attribute of the query input element. The branch should continue to pass all the tests.
1. Confirm your solution by performing various searches in your browser. Verify that searching works correctly with:
   - a button click
   - a button focus and `ENTER`
   - a button focus and `SPACE`
   - a query input focus and `ENTER`

## <a name="completion"></a>Completion

Your new tests and revisions have made the application respond dynamically to user activity. Variables and functions in the root component (`app.component.ts`) comprise a model that stores values and implements logic to make the view respond. Your current tests examine the view, but not the model. In the next lesson you will add tests of the model.

1. Open the `README-switch.md` file and follow the &ldquo;Completion&rdquo; instructions.

==> tdd-lab.npm/lessons/08/README-08.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 8: Model Testing

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Configure model tests](#configure)
- [Test variables](#variables)
- [Test functions](#functions)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will add unit tests of the model to your application.

In Lesson 7 you added options and dynamic results to your application. The application&rsquo;s behavior is governed by variables and logic in its template and in its component. For example:

- The **template** contains a reference variable `query` (coded as the attribute `#query`).
- The **component** contains a variable `mode`.
- The **template** contains an event binding that changes the value of `mode` when a radio button is checked.
- The **component** contains a function that converts a name to the lower-case string that a query is to be matched against, given the current search mode.

Your unit tests currently examine the template, but not the component. A robust set of unit tests also includes tests of the component. Such tests protect the application from future changes that would stop it from behaving as intended.

Roughly, the template encodes the application&rsquo;s _view_, and the component encodes its _model_, so component testing is what is commonly described as &ldquo;model&rdquo; testing. In this lesson you will add some model tests to your application.

## <a name="setup"></a>Setup

1. Open the `README-switch.md` file and follow the &ldquo;Setup&rdquo; instructions.

## <a name="configure"></a>Configure model tests

1. Create a group for the model, just before the close of the `AppComponent` group in `app.component.spec.ts`.

## <a name="variables"></a>Test variables

1. Add this Jest test to the new group, to require the initial value of `mode` to be `'whole'`:

   ```typescript
   it('initial value of mode should be whole', () => {
     expect(app.mode).toBe('whole');
   });
   ```

   The branch should pass this test and all subsequent tests, because they test behavior that you have already implemented.
1. Add a similar test for the initial value of `summary`.
1. Add a similar test for the initial value of `resultNames`. In this case, you expect an array value, not a string, so the appropriate matching method is `toEqual()` rather than `toBe()`. In case the actual value is a different array, Jest will compare the array elements and report where it found differences.

## <a name="functions"></a>Test functions

1. Add this test for the behavior of the `modeNameOf()` function:

   ```typescript
   it('whole name of Karal,Arag should be karal,arag', () => {
     expect(app.modeNameOf('Karal,Arag')).toBe('karal,arag');
   });
   ```

1. Add a similar test for the same function when the search mode is `family`. To do this, insert this statement before the `expect()` statement:

   ```typescript
   app.mode = 'family';
   ```

   You may keep the same name or choose a different name for this test.
1. Add a similar test for the same function when the search mode is `given`.
1. Add this test for the behavior of `getMatchingNames()` in whole-name mode:

    ```typescript
    it('result names of a whole search should be correct', () => {
      app.query = 'La';
      expect(app.getMatchingNames()).toEqual(['Xhelaj,Romeo', 'Xia,Angela']);
    });
    ```

    This test will run in whole mode, even though the previous test assigned `'given'` to `app.mode`. That&rsquo;s because the test application is recreated before each test by the `beforeEach()` function at the beginning of the `AppComponent` group.
1. Add a similar test for the same function, with `'ei'` as the query, when the search mode is `given`. This will verify that your application properly handles duplicate names.
1. Add a similar test with a mode of your choice, giving a non-matching argument such as `'xyzabc'` to `getMatchingNames()`.
1. Add a similar test, giving an empty argument. The expected array contains all 20 names, so, instead of testing for the array, test for its `length` property. The expected value is a number, so the matching method should be `toBe()`.
1. Add this test for the behavior of `getSummary()`:

   ```typescript
   it('summary should be correct', () => {
     app.matchingNames = ['a', 'b', 'c'];
     expect(app.getSummary()).toBe('Matching name count: 3');
   });
   ```

1. Add this test for the behavior of `handleQueryChange()`:

   ```typescript
   it('should correctly handle a query change in whole mode', () => {
     app.handleQueryChange('rr');
     expect(app.summary).toBe('Matching name count: 2');
     expect(app.resultNames).toEqual([]);
   });
   ```

1. Add a similar test for the `given` mode, setting the mode before calling the `handleQueryChange()` function.
1. Add this test for the behavior of `handleModeChange()`:

   ```typescript
   it('should correctly handle a change to family mode', () => {
     app.handleModeChange('family', 'rr');
     expect(app.summary).toBe('Matching name count: 1');
     expect(app.resultNames).toEqual([]);
   });
   ```

1. Add a similar test for a change to `given` mode with `'xi'` as the query.
1. Add this test for the behavior of `handleQuerySubmission()`:

   ```typescript
   it('should correctly handle a submission in whole mode', () => {
     app.handleFormSubmission(new Event('submit'), 'f');
     expect(app.summary).toBe('Matching name count: 2');
     expect(app.resultNames).toEqual(['Xu,Fei', 'Xu,Fei']);
   });
   ```

1. Add a similar test for `family` mode.

## <a name="completion"></a>Completion

Your new tests have not required any changes in the application. They protect the application from future changes that would make it deliver incorrect results, thereby making it even more robust. By examining the behavior of the model, they also help you diagnose the origin of any test failures that might occur.

In the next lesson you will use a battery of tests created by others, rather than writing your own tests.

1. Open the `README-switch.md` file and follow the &ldquo;Completion&rdquo; instructions.

==> tdd-lab.npm/lessons/09/README-09.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 9: Test Packages

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Configuration](#configuration)
- [Test](#test)
- [Test functions](#functions)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will add tests from an external package to the application.

In Lesson 8 you wrote model tests for your application. They supplemented other Jest and Cypress tests that you had written.

Some of your tests are specific to your particular application, so you could not expect any existing test package to contain those tests.

But other tests are generic. For example, one test requires all `input` elements to belong to forms. Some generic tests can be found in packages, so you can run them without needing to write them first.

In this lesson you will practice using a battery of tests from an existing package, in addition to the tests that you have written.

## <a name="setup"></a>Setup

1. Open the `README-switch.md` file and follow the &ldquo;Setup&rdquo; instructions.

## <a name="configuration"></a>Configuration

1. You will add a package of tests to your existing unit tests. The package is `jest-axe`. It tests conformity to some of the [WCAG](https://www.w3.org/TR/WCAG21/) standards that [Utopia is committed to respecting](https://about.Utopia.com/accessibility/accessibility.html) in its UIs, using the `axe` rules engine. To use this package, in your code editor, open `package.json` and add the latest version of `jest-axe` to the developer dependencies. You can find the latest version with a search of [local npm mirror](). (There is also a `cypress-axe` package using the same `axe-core` test suite, but [it has not yet been made fully compatible with the infrastructure of an Angular application](https://github.com/avanslaars/cypress-axe/issues/7).)
1. Add the latest version of `@types/jest-axe` to the developer dependencies. To find that version, just add `types` to the &ldquo;Scope&rdquo; field in the search form. This package specifies types for `jest-axe` variables, allowing you to use them with TypeScript.
1. Finally, add the latest version of `axe-core` to the developer dependencies, finding the version in the same way as `jest-axe`. The `jest-axe` package may specify an older version of `axe-core`. With this entry in `package.json`, you will make `jest-axe` use the latest version available at Utopia.
1. If your code editor tells you that other packages are specified with old versions, you may also update the versions to match what is actually installed.
1. In your bash shell, install these new dependencies (`npm install`). You may disregard warnings about optional dependencies and Python-related errors.
1. Make it possible for your Jest tests to use the package by adding these statements to the `import` statements in `app.component.spec.ts`:

   ```typescript
   import { axe, toHaveNoViolations } from 'jest-axe';
   expect.extend(toHaveNoViolations);
   ```

1. Stop the Jest testing (`CTL-c`) and start it again (`npm run watch:unit`) to make it use the configuration changes.

## <a name="test"></a>Test

1. At the end of `app.component.spec.ts`, after the end of the model group and just before the end of the `AppComponent` group, add this statement to run the entire set of `axe-core` tests:

   ```typescript
   it('should comply with the axe-core rules', async () => {
     expect(await axe(compiled)).toHaveNoViolations();
   });
   ```

   The branch should pass this suite of tests, along with your other tests. If it fails any `axe-core` test, inspect the diagnostics.
1. Observe how `jest-axe` behaves when you deliberately introduce into the template a defect that it tests for. To introduce a defect:

    1. Add `id="summary"` to the `ul` element.
    1. Insert the line `<label for="summary">List of matching names</label>` after the closing tag of the `section` element.

    These changes violate the HTML5 prohibition on duplicate `id` attributes and make that violation more severe by creating a label whose labeled element is ambiguous. Save the Jest file, and Jest should then report a failure on the `jest-axe` test.

1. Remove the deliberate errors. The branch should then pass all the tests again.

1. Add another defect and discover whether `jest-axe` discovers it.

Tests with various versions of `jest-axe` have revealed large differences in its success rates. Version 3.2.0 was performing well, but version 3.4.0 failed to detect most defects. The duplicate `id` values, for example, were not discovered when no `label` element referred to them, even though that is a violation of `axe-core` and is reported by the `axe` browser extension. This illustrates that test packages cannot be blindly trusted. Moreover, even when they work as intended, they often do not test as specifically as you can by writing your own tests.

## <a name="completion"></a>Completion

You have made your testing more comprehensive with a suite of tests from a Jest package. If any of the package tests duplicate your custom tests, you could remove the custom tests. However, typically a custom test is more specific, so a package test doesn&rsquo;t duplicate it. For example, `axe-core` requires `input` elements to have labels, but your custom tests require specific labels, not just any labels.

In the next lesson you will re-implement the form in your application, making it a separate component that uses Angular&rsquo;s reactive-form mechanism.

1. Open the `README-switch.md` file and follow the &ldquo;Completion&rdquo; instructions.

==> tdd-lab.npm/lessons/10/README-10.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 10: Reactive Forms

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Create form component](#component)
- [Configure model](#configmodel)
- [Configure styles](#configstyles)
- [Split template and styles](#splitts)
- [Configure Jest tests](#configjest)
- [Split Jest tests](#splitjest)
- [Reference component](#refcomponent)
- [Add reactive mechanism](#mechanism)
- [Make application and tests reactve](#appreactive)
- [Handle changes](#handlechange)
- [Make Jest model tests reactive](#jestreactive)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will reimplement a form as an Angular reactive form.

In Lesson 9 you added packaged tests to your application. The application was already in conformity with the standards that they test for, so you did not need to change your implementation.

In this lesson you **will** change the implementation. Specifically, you will change the technology underlying the search form. This will give your application a more modular architecture.

Angular offers two architectures for form management. For simple forms that don&rsquo;t need much testing, there is a &ldquo;template-driven&rdquo; architecture. For more complex forms that require thorough testing, there is a &ldquo;reactive&rdquo; architecture. At Utopia, clients use forms to give us instructions to buy, sell, deposit, withdraw, and transfer, and to answer our questions about their financial conditions and investment goals. Crew members use many third-party forms, but also forms built here, such as when they perform crew searches. Forms are a crucial part of many Utopia UIs and need meticulous testing. The [Angular documentation](https://angular.io/guide/forms-overview) recommends the reactive architecture for UIs like ours. So, in this lesson you will convert your form to Angular&rsquo;s reactive architecture.

Your current form is embedded in the root component (`src/app/app.component`). All details and tests of the form are there, distributed among the component&rsquo;s `.ts`, `.html`, and `.spec.ts` files.

In the reactive-form architecture, you will encapsulate the form into its own component. The form&rsquo;s details will be there, not in the `app.component` files.

The values of controls in your reactive form will have two manifestations: a view and a model. Angular keeps them synchronized in both directions.

Once your reactive architecture is in place, you will be able to add some additional Jest tests checking new behaviors of the form&rsquo;s model, like the tests you added in Lesson 8.

The plan for this lesson is to:

1. rearchitect the form
1. ensure that the branch continues to pass all tests
1. add Jest tests on the form model
1. ensure that the branch passes those new tests

## <a name="setup"></a>Setup

1. Open the `README-switch.md` file and follow the &ldquo;Setup&rdquo; instructions.

## <a name="component"></a>Create form component

1. You will now reorganize the form architecture in accord with the Angular reactive-form approach. Begin this process in your code editor by adding a script to `package.json`, if it is not already there. Name the script `"ng"`, and give it `"ng"` as its value.
1. In your bash shell, use that script to create a search-form component for the form (`npm run ng generate component SearchForm`). The new component is located in a `search-form` directory inside the `app` directory. It includes a `spec.ts` file with one test. Jest in watch mode should notice the addition of that file, increasing the count of passed tests by 1 and adding `src/app/search-form/search-form.component.spec.ts` to the list of passed tests.

## <a name="model"></a>Configure model

1. Both of your components have `component.ts` files where their models are defined. A new Angular component by default implements the `ngOnInit()` &ldquo;lifecycle hook&rdquo; method and the `environment` variable. This component will not require either of them. So, in `src/app/search-form/search-form.component.ts`, delete `implements OnInit`, the `ngOnInit()` function declaration, the importation of `OnInit`, the initialization of `environment`, and the importation of `environment`. This should not change the test results.
1. You will copy form-related content from the `app.component.ts` to the `search-form.component.ts` file and, when finished, remove that content from the `app.component.ts` file. Start by copying the `names` import statement. The destination file is embedded one level deeper in the filesystem, so, in the copy, insert an additional `../` into the relative URL.
1. Almost all of the members of the `AppComponent` class relate to the form. The only exception is the `title` variable. So copy all the rest into the `SearchFormComponent` class, before the constructor.
1. Delete the constructor, since it is empty.

## <a name="styles"></a>Configure styles

1. The styles of your application are currently defined in `src/styles.scss`, a general stylesheet for the entire application. But the newly generated component has its own empty stylesheet, `search-form.component.scss`. You can use that stylesheet for styles that are specific to the form. General styles, too, will apply to the form. To make both stylesheets available to the new component, begin the new component&rsquo;s stylesheet with this CSS at-rule:

   ```scss
   @import url('../../styles.scss');
   ```

   In principle, there is another mechanism for this purpose, namely adding `'../../styles.scss'` to the array value of the new component&rsquo;s `styleUrls` property. However, that mechanism [triggers an Angular bug](https://stackoverflow.com/a/59697680/1572601).

## <a name="split"></a>Split template and styles

1. Copy the `form` and `section` elements from `app.component.html` into `search-form.component.html`, replacing the original content of the destination template.
1. Copy the form-related rulesets from `styles.scss` into `search-form.component.scss`. These are the rulesets with selectors for any:
   - `button`
   - `label`

## <a name="configjest"></a>Configure Jest tests

1. Your Jest tests are now in the `src/app/app.component.spec.ts` file. Those tests will encounter a `crewinfo-search-form` element in the template. When they do, they will need to interpolate the search-form component at that location. To make that happen, add two things to the file:
   1. Under the `AppComponent` import statement, a similar import statement for the new component:

      ```typescript
      import { SearchFormComponent } from './search-form/search-form.component';
      ```

   1. In the argument to `TestBed.configureTestingModule()`, a second element in the array value of the `declarations` property: `SearchFormComponent`.
1. In the callback argument to the `describe()` function in `search-form.component.spec.ts`, add a declaration for the variable `compiled`, as in `app.component.spec.ts`.
1. In the argument to the `beforeEach()` function, after the initialization of `component` add the same initialization of `compiled` as in `app.component.spec.ts`.

## <a name="splitjest"></a>Split Jest tests

1. You will copy form-related Jest tests from `app.component.spec.ts` into `search-form.component.spec.ts`. Start with the test for a search field with `query` as its ID inside the `main` landmark. After copying this test, revise it so it can pass. This requires removing `main` from the selector, because the `main` element is in the root component, not in the form component. Also remove the reference to the main landmark from the test description. The branch should pass this new version of the test.
1. Copy the test on the labeling of the query input.
1. Copy the two tests on a button in the `main` landmark. Change `main` to `form` in the copies&rsquo; bodies and descriptions, because the `main` landmark is not in the search-form component. The branch should pass the new test versions.
1. Copy the test on a form followed by a section. In the copy, remove &ldquo;main&rdquo; from the description, and remove `main >` from the body. The branch should pass the new test.
1. Copy the test for the text content of the `h2` element. In the body of the copy, remove the `main >`. The branch should pass the new test.
1. Copy the test for the text content of the first button. In the copy, change `main` to `form` in both the body and the description. The branch should pass the new test.
1. There are 6 more tests before the model group. They should work without modification. Copy them.
1. Copy the whole model group. In the copy, change all of the references to `app` so they refer, instead, to `component`. The `fixture.componentInstance` variable is named `app` in the root component, but is named `component` in the search-form component. (`fixture.componentInstance` is a shorthand equivalent of `fixture.debugElement.componentInstance`.)

## <a name="refcomponent"></a>Reference component

1. Make your application use the new component. To do this:
    1. Insert into the `main` element of the root component&rsquo;s template a custom element referencing the form component: `<crewinfo-search-form></crewinfo-search-form>`.
    1. Delete the `form` and `section` elements (with their contents).
    1. In `app.component.spec.ts`, delete all of the tests that you copied, namely the tests after the test for the text restatement of the logotype and before the test for axe-core rules.
    1. In `app.component.ts`, delete all of the members of the `AppComponent` class except `title`, since you have moved them into `search-form.component.ts`.
    1. Also delete the statement importing `names`.

1. By removing `main` from selectors of copied tests, you have weakened those tests, potentially allowing elements to be located outside the main landmark. To guard against this, add this test to `app.component.spec.ts`, before the `axe-core` test:

   ```typescript
   it('should contain a form component child of the main landmark', () => {
     expect(compiled.querySelector('main > crewinfo-search-form')).toBeTruthy();
   });
   ```

   This test guarantees that all the elements in the form component are also in the `main` element. The branch should continue to pass all the tests.

1. Delete the rulesets from `styles.scss` that you have copied into `search-form.component.scss`. The deletions should leave the branch still passing all the tests.

## <a name="mechanism"></a>Add reactive mechanism

1. Make Angular&rsquo;s reactive-form mechanism available to your application. It is in a module named `ReactiveFormsModule`, located in a package called `@angular/forms`. To make it available, import it into:
    1. `app.module.ts`
    1. `app.component.spec.ts`
    1. `search-form.component.spec.ts`
1. Also add the name of that module to the `imports` array of:
    1. the `@NgModule` class in `app.module.ts`
    1. the `imports` property of the argument to `TestBed.configureTestingModule()` in the `beforeEach()` statement of the main test group in:
        1. `app.component.spec.ts`
        1. `search-form.component.spec.ts` (you may need to add the `imports` property)

## <a name="appreactive"></a>Make application and tests reactive

1. To make the search form reactive, you will use the `FormControl` and `FormGroup` classes from `@angular/forms`. Add to `search-form.component.ts` another `import` statement, importing both of those classes from that package.
1. Create a new instance of the `FormGroup` class and add it as the first member of the `SearchFormComponent` class in `search-form.component.ts`, with this code:

    ```typescript
    searchForm = new FormGroup({
      queryField: new FormControl(''),
      mode: new FormGroup({
        mode: new FormControl('whole')
      })
    });
    ```

    This object is a model of the form. Its value will be an object synchronized with the values of the controls in the form. At any time, the query will be the same as `searchForm.value.queryField`, and the selected search mode will be the same as `searchForm.value.mode.mode`.
1. In `search-form.component.html`, begin to associate the form with the `searchForm` object that you just created. To do this, add a property-binding attribute, `[formGroup]="searchForm"`, to the `form` element.
1. Associate the query input of the form with the `queryField` property of the `searchForm` object by adding the attribute `formControlName="queryField"` to that `input` element.
1. Associate the `fieldset` element with the outer `mode` property of the `searchForm` object by adding the attribute `formGroupName="mode"` to the `fieldset` element.
1. Whatever you named the radio buttons before, now you now need to give them the same name as the property of `searchForm` that represents them, namely `"mode"`. So, ensure that they all have the attribute `name="mode"`.
1. In addition to their `name` attributes, give the radio buttons&rsquo; `input` elements the attribute `formControlName="mode"`, to associate them with the `searchForm` model.
1. You have now ensured that the current query and search mode are retrievable from the `searchForm` object in the model. Therefore, you no longer need the `query` and `mode` members of the `SearchFormComponent` class. Delete them.
1. The `modeNameOf()` function refers to the `mode` variable that you just deleted. Update the function by:
    1. Redefining `mode` as a local variable within the function, like this:

        ```typescript
        const mode = this.searchForm.value.mode.mode;
        ```

    1. Changing all the references to `this.mode` to `mode` within the function.
1. Revise `query` in the `getMatchingNames()` function similarly.

## <a name="handlechange"></a>Handle changes

1. You have synchronized the view and the model. With the reactive architecture, you will no longer need the `handleQueryChange()` and `handleModeChange()` functions. The synchronizations they produce in their first statements will take place automatically. So the `handleChange()` function will work for both query changes and search-mode changes. To make it do so, change the call to `handleQueryChange()` and the three calls to `handleModeChange()` in the search-form template, making them all calls to `handleChange()`.
1. Now that you have made the `handleQueryChange()` and `handleModeChange()` functions unnecessary, delete them from `search-form.component.ts`.
1. With these changes, user actions on the query and search-mode controls produce two parallel effects on the model:
    - The `formControlName` attributes link these controls to the `searchForm` object in the model. Any change in an input value produces an identical change within the `searchForm` object.
    - The `input` and `change` event bindings cause the `handleChange()` function to be executed.

    However, there is something questionable about this parallelism. What if `handleChange()` executed **before** `searchForm` is updated? The result would be wrong. So you need a guarantee that the `searchForm` updating will occur first.

    Why can&rsquo;t `handleChange()` notice changes in the value of `searchForm` and execute itself whenever they occur, instead of depending on the view to notify it in parallel? Then it would be guaranteed to operate on the updated values. Well, it can. The `searchForm` instance inherits from its `FormGroup` class an _observable_ property named `valueChanges`. Functions can _subscribe_ to an observable. When the value of `searchForm` changes, its `valueChanges` observable notifies its subscribers, causing them to run. Here, a subscriber can execute `handleChange()` whenever the query or the search mode changes. To make use of this feature, after the `handleChange()` function add this new subscriber:

    ```typescript
    watchSearchForm: () => void = () => {
      this.searchForm.valueChanges.subscribe({
        next: () => {
          this.handleChange();
        }
      });
    };
    ```

1. When the view loads, the application needs to execute `watchSearchForm()`, to perform the subscription. To make this happen, add this constructor at the end of the `SearchFormComponent` class:

   ```typescript
   constructor() {
     this.watchSearchForm();
   }
   ```

1. You have now made the `change` and `input` event-binding attributes of the `input` elements in the search-form template unnecessary. Delete them.
1. The deleted `input` event binding was the only user of the query input&rsquo;s template reference variable `#query`, so delete it.

## <a name="jestreactive"></a>Make Jest model tests reactive

1. Revise the test for the initial mode to:

   ```typescript
   it('initial value of mode should be whole', () => {
     expect(component.searchForm.value.mode.mode).toBe('whole');
   });
   ```

1. Now that the model stores the query as well as the mode, add a similar test for the initial value of the query.
1. Some tests in the model group assign values to `component.query`. That class member no longer exists. The store of the current query is now `searchForm.value.queryField`. However, the `value` property of a `FormGroup` instance is read-only. Instead of assigning a value to one of its properties, you must use its `patchValue()` method. At the beginning of the model group, add this function to help you do that:

    ```typescript
    const setQuery = (formModel, newQuery) => {
      formModel.patchValue({ queryField: newQuery });
    };
    ```

1. Some tests, similarly, assign values to `component.mode`, which likewise has been replaced with a property of `searchForm.value`. Add a similar function to the model group for modifying the search mode. The argument of `patchValue()` needs to be `{ mode: { mode: newMode } }`.
1. Now you can use these functions to replace all statements in tests that assign values to `component.query` and `component.mode`. For example, `component.query = 'ei'` becomes `setQuery(component.searchForm, 'ei')`. And `component.mode = 'given'` becomes `setMode(component.searchForm, 'given')`.
1. Some tests call the `handleQueryChange()` and `handleModeChange()` functions, but those functions no longer exist. Revise those tests by calling `setQuery()` and/or `setMode()` and then `handleChange()`. Here is one example of how such a revised test would be coded:

    ```typescript
    it('should correctly handle a query change in given mode', () => {
      setMode(component.searchForm, 'given');
      setQuery(component.searchForm, 'rr');
      component.handleChange();
      expect(component.summary).toBe('Matching name count: 1');
      expect(component.resultNames).toEqual([]);
    });
    ```

    The branch should pass all the tests when you complete these revisions.

## <a name="completion"></a>Completion

You have now reimplemented your application to make use of Angular&rsquo;s reactive-form architecture. This simplified the template. User actions in the form now start a chain reaction, including an observable value change that a function subscribes to. Variables in the model are revised, and finally the result in the view is updated.

In the next lesson you will start obtaining real data on crew members from Utopia&rsquo;s crew search service, instead of a fixed sample of data.

1. Open the `README-switch.md` file and follow the &ldquo;Completion&rdquo; instructions.

==> tdd-lab.npm/lessons/11/README-11.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 11: Services

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Revise Jest tests](#jest)
- [Revise Cypress test, fail](#jest)
- [Reconfigure](#reconfigure)
- [Create service](#create)
- [Use service](#use)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will make your application obtain data from a service.

In Lesson 10 you reorganized the form component in your application to employ the reactive architecture offered by Angular. But the data used by the application were still a fixed sample of crew data.

In this lesson you will replace the sample with data from the [Utopia Crewfinder REST service](http://confluence.Utopia.com:8090/pages/viewpage.action?pageId=35591900). You will use [Angular&rsquo;s service architecture](https://angular.io/guide/architecture-services) for this purpose.

Using real data makes your application useful, but complicates testing. You can no longer count on the stability of the list of crew members&rsquo; names over time. You must redesign some tests to tolerate partly unpredictable data.

Getting real data from a server is an asynchronous operation. A statement requesting the data executes immediately, and the following statements don&rsquo;t wait. But it takes time for the data to arrive, so the following statements will produce incorrect results if they assume that the data are already available. Your tests need to wait where necessary.

Once your application uses real data, you must also be mindful of possible problems of scale. Some operations might take too long when performed on a database of all crew members. A list of matching names might be too large if it includes many or even all crew members.

In fetching real data, you must decide between two strategies:

1. Whenever you need data, submit a query to the Crewfinder API.
1. When the application first needs data, get all the data you might need from the Crewfinder API, and after that use your local copy of the data.

In this lesson, you will implement strategy 2. The reasons for this choice are:

- Querying the API after every keypress would introduce additional latency as the user waits for the API to respond.
- The API doesn&rsquo;t calculate a count of matching names for the client; instead, it sends the records for all crew members with matching names to the client. Crew member records average about 1400 characters in length. So strategy 1 would require the transmission, on each keypress, of much more traffic than just names.
- The API permits queries about family names and given names, like your application, but does **not** permit matching in the middle of a name. All queries are matched against the **beginning** of each name. So, implementing strategy 1 would require you to change the matching algorithm and the instructions, eliminating an existing feature.
- The API does not permit empty queries. To get the count, or a list, of all names from the API, you would need to submit 26 queries to the API: one for `A`, one for `B`, etc.

The plan for this lesson is to:

1. revise the tests to cover the use of live data
1. replace the sample data with live Crewfinder data
1. ensure that the branch continues to pass all tests

## <a name="setup"></a>Setup

1. Open the `README-switch.md` file and follow the &ldquo;Setup&rdquo; instructions.

## <a name="jest"></a>Revise Jest tests

Some of your current tests assume that the application will get the names of crew members from an `assets/names.ts` file. You can no longer assume this. The application will generally get the names from the Crewfinder API. But tests should also be able to _mock_ the API, i.e. to operate on a fixed sample of names, as they have up to now, so you can safely predict the correct behavior.

1. In both `app.component.spec.ts` and `search-form.component.spec.ts`, add a statement importing `HttpClientModule` from `'@angular/common/http'`. This will permit your Jest tests to compile the search-form component when it begins to use HTTP to obtain names (even if the Jest tests mock the names).
1. In both those files, add `HttpClientModule` to the array value of the `imports` property of the argument to `TestBed.configureTestingModule()`.
1. In the search-form Jest tests&rsquo; model group&rsquo;s callback argument, after the definitions of `setQuery()` and `setMode()`, add this constant definition. Fill in the 20 names from the `names.ts` file:

   ```typescript
   const names = [
     'Xerri,Natalie',
     '...',
     'Xuereb,Paul'
   ];
   ```

1. Before the first test in the model group, add this statement:

   ```typescript
   beforeEach(() => {
     component.allNames = names;
   });
   ```

   This statement assumes that the `SearchFormComponent` class will have an `allNames` member containing a complete array of the names. By setting its value to the array of 20 sample names, this statement will let you test the model with that sample.

## <a name="cypress"></a>Revise Cypress test, fail

Although your Jest tests use mocked data, it is beneficial to do some testing on the live data from the Crewfinder service. Integration tests are appropriate for that. The existing last test in `app.spec.ts` will fail with live data, because it is based on a sample of 20 names. Revising it to expect results from the live data will require:

- giving the application time to finish retrieving the live data
- modifying any expected strings that depend on a single particular name
- setting the range boundaries realistically for the live data

1. Insert this statement after the first `setMode()` call in your last Cypress test:

   ```typescript
   cy.wait(10000);
   ```

   This makes Cypress wait 10 seconds. The `setMode()` execution causes a change in the value of the model&rsquo;s `searchForm` object, which then makes its subscriber `handleChange()` execute. Since this is its first execution after the view loads, it retrieves all the records from the Crewfinder service. The `cy.wait()` call allows time for the retrieval before the records are used.
1. Revise some of the range arguments to `checkSummary()` and `checkNames()`. Specifically, revise the range boundaries other than `-1, 1` as follows:
   - from `19, 21` to `20000, 30000`
   - from `1, 3` to `3000, 6000`
   - from `11, 13` to `4000, 8000`

1. Revise the arguments of the first call to `checkNames()` after `submitForm()` is called. Change both arrays of strings to make them realistic for the query `'u'`. For example, you can expect the matching names to include `'Paul'`, but not to include `'xuxz'`.

    The branch should fail this revised test. Once you have reimplemented the application to use live data, the branch will continue to fail, because the ranges given above are not entirely correct. You will use the diagnostics in the Cypress Command Log to decide on realistic values for the ranges.

## <a name="reconfigure"></a>Reconfigure

1. Enable the use of the Crewfinder API. The Crewfinder API, implementing the [CORS standard](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS), permits queries only from inside the `Utopia.com` network. In the `angular.json` file, you previously changed the value of the `projects.crewinfo-angular.architect.serve.options.host` property from `"localhost.Utopia.com"` to `"localhost"` so that you could develop and test your application even when not connected to the Utopia (or any) network. But the API will reject queries from `localhost`. So use your code editor to restore the original value of the `host` property.

## <a name="create"></a>Create service

1. In your bash shell, create a `crewfinder` service within a `crewfinder` directory in the `app` directory (`npm run ng generate service crewfinder/crewfinder`). This command should create an `app/crewfinder` directory, containing:
   - a `crewfinder.service.ts` file, which:
     - imports the `Injectable` class
     - defines a `CrewfinderService` class with an empty constructor
   - a `crewfinder.service.spec.ts` file with a test
1. The `crewfinder` service will connect to Utopia&rsquo;s Crewfinder REST API to get data. It will use the HTTP protocol for this connection, like a web browser. To give the module access to the HTTP protocol, in `app.module.ts`:
   1. Add a statement importing `HttpClientModule` from `'@angular/common/http'`.
   1. Add `HttpClientModule` to the array value of the `imports` property of the argument to the `@NgModule` decorator.
1. To give the `CrewfinderService` class access to the `get()` method of the `HttpClient` class:
   1. Add to the `crewfinder.service.ts` file a statement importing `HttpClient` from `'@angular/common/http'`.
   1. Add the argument `private http: HttpClient` to the constructor of the `CrewfinderService` class.
1. Add a member to that class identifying the URL hosting internal Utopia APIs: `apiURL = 'https://apii.cf.opsp.c1.Utopia.com';`.
1. Add a similar member identifying the remainder of the URL for the Crewfinder API: `crewfinderURL = 'rs/cf/crewfinder-webservice/public/people';`.
1. Add to the class this function retrieving the records of crew members whose family names begin with a specified string:

   ```typescript
   getRecordsByNameStart: (n: string) => any =
     nameStart => this.http.get(
       `${this.apiURL}/${this.crewfinderURL}?lastName=${nameStart}`
     );
   ```

   The `get()` method returns an Observable. A calling function can subscribe to it. When the response has been received, the subscriber will act on the data.

1. To give Jest access to the `HttpClientModule`, add to `crewfinder.service.spec.ts`:
   1. a statement importing `HttpClientModule` from `'@angular/common/http'`
   1. the property `imports: [HttpClientModule]` in the object argument of the `TestBed.configureTestingModule()` method

## <a name="use"></a>Use service

1. In `search-form.component.ts`, add a statement importing `CrewfinderService` from `'../crewfinder/crewfinder.service'`.
1. Make an instance of the `CrewfinderService` class available to the `SearchFormComponent` constructor by inserting a `private crewfinderService: CrewfinderService` argument into the currently empty argument list.
1. Change the initial value of `allNames` from `names` to `[]`;
1. Remove the import statement for `names`.
1. After `modeNameOf()` define this function, **recursively** fetching the records from a specified letter to Z and then calling a function:

   ```typescript
   getRemainingNames: (s: number, e: number, c: () => void) => void = (
     startCharCode,
     endCharCode,
     callback
   ) => {
     this.crewfinderService
       .getRecordsByNameStart(String.fromCharCode(startCharCode))
       .subscribe(data => {
         this.allNames.push(
           ...data.map(record => {
             const name: string = record[`preferredName`].nameLastFirst;
             return name.replace(', ', ',');
           })
         );
         if (startCharCode < endCharCode) {
           this.getRemainingNames(++startCharCode, endCharCode, callback);
         } else {
           this.allNames.sort();
           callback();
         }
       });
   };
   ```

   This function requires two numbers and a function as arguments. The two numbers are character codes. It calls the `getRecordsByNameStart()` method of the `CrewfinderService` class on the first number&rsquo;s character, using the `String.fromCharCode()` method to get that character. By subscribing, it waits for the Observable result. That result is an array of objects, one object per crew member. For each object, it finds the `preferredName.nameLastFirst` property. It reformats that name by deleting the space after the comma, conforming it to the format used in this application. Then it pushes all of the names in the batch onto the `allNames` array.

   After processing the batch, it determines whether it is the last batch to be processed. If not (i.e. if the character code is less than the last character code), it executes itself again, after incrementing the character code by 1. If this **was** the last batch, it finishes by sorting the `allNames` array alphabetically and then calling the callback function that was specified as the third argument.

   In this way, the function ensures that the callback function will wait for all the names to be retrieved and added to the `allNames` array, before being executed.

1. Define this function to populate the `allNames` array with all the names from `a` to `z`:

   ```typescript
   getAndUseNames: (c: () => void) => void = callback => {
     const startCharCode = 65;
     const endCharCode = 90;
     this.getRemainingNames(startCharCode, endCharCode, callback);
   };
   ```

1. Revise the `handleChange()` function to make use of `getAndUseNames()`:

    ```typescript
    handleChange: () => void = () => {
      const useNames: () => void = () => {
        this.matchingNames = this.getMatchingNames();
        this.summary = this.getSummary();
        this.resultNames = [];
      };
      if (this.allNames.length) {
        useNames();
      }
      else {
        this.getAndUseNames(useNames);
      }
    }
    ```

    This new version does the same things it previously did if `allNames` contains any names. If `allNames` is empty, however, it first executes `getAndUseNames()` to retrieve the names from the service and waits for the names to be retrieved before using them to assign values.

    So, when the view loads, `allNames` will be an empty array. When the user first changes the query or the search mode, `handleChange()` will run for the first time, find `allNames` empty, retrieve the names from the service, populate `allNames`, and then assign values to the three variables. Whenever the user subsequently modifies the query or the search mode, `handleChange()` will find `allNames` non-empty, so it will simply assign values to the variables, based on the existing `allNames` array.

1. You have changed the behavior of the application when the view loads. Previously it initialized `allNames` with an array of 20 names, and now it initializes `allNames` with an empty array. So, revise the Jest test for the initial summary so it expects a count of 0 instead of 20. This change should make the branch once again pass all the Jest tests.

1. The branch should fail your last Cypress test, because some results should fall outside the specified ranges. Inspect the Cypress Command Log to find the actual counts. Revise the ranges to enclose the actual results, allowing a reasonable margin for future changes in crew size and names. After that, the branch should pass all the tests.

1. The application no longer gets its names from the `src/assets/names.ts` file, so that file is now obsolete. Remove it.

## <a name="completion"></a>Completion

You have now made your application use real data to provide search results to users. Until now all interactions have taken place in a single view.

In the next lesson you will add a second view to the application. The list of matching names will become a list of links. Activating a link will take the user to a new view, containing detailed information about the crew member named by that link.

1. Open the `README-switch.md` file and follow the &ldquo;Completion&rdquo; instructions.

==> tdd-lab.npm/lessons/12/README-12.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 12: Routing

## Table of contents

- [Introduction](#introduction)
- [Setup](#setup)
- [Revise Jest tests](#revisejest)
- [Add Jest test](#addjest)
- [Revise Cypress tests](#revisecypress)
- [Add Cypress tests](#addcypress)
- [Revise, pass](#revise)
- [Create service](#create)
- [Use service](#use)
- [Completion](#completion)

## <a name="introduction"></a>Introduction

In this lesson you will enhance your application to offer two views on two routes.

### Introduction

In Lesson 11 you replaced sample data with real data from a service and revised your Cypress tests to accommodate variability in results and allow time for results to arrive.

When users search with your application, they currently get only names. But the Utopia Crewfinder service provides more than names. In this lesson you will make your application provide additional data about selected persons. To do this, you will change the result in the home view, converting a list of names to a list of person links. When a user activates one of the links, the application will switch to another view, where details about the selected person will be displayed. In this detail view, there will also be a link bringing the user back to the home view.

The plan for this lesson is:

1. revise Jest tests
1. add Jest test for a new detail component
1. revise Cypress tests
1. revise the implementation to include the new feature
1. ensure that the branch passes all the tests
1. revise Jest tests on the search-form model???
1. add Jest tests on the detail model

## <a name="setup"></a>Setup

1. Open the `README-switch.md` file and follow the &ldquo;Setup&rdquo; instructions.

## <a name="revisejest"></a>Revise Jest tests

1. One of your tests in `app.component.spec.ts` requires the `main` element to have `crewinfo-search-form` as a child element. That component has provided the only view in the application. Now, however, there will be two views. The Angular router will decide which view appears. The standard mechanism for that choice is a `router-outlet` component. Therefore, revise that test so the expected child is a `router-outlet` element. The branch should fail the revised test.

Your tests in `search-form.component.spec.ts` are of two kinds:

- tests of the view before any search result
- tests of the model

The pre-result view tests should all be viable, without change, after you introduce a second view. The result will become links, but those tests don&rsquo;t deal with the result. Nothing else in the search-form view will change.

On the other hand, you will need to revise the tests of the model, because the model will now handle details, not only names, of persons. But you have not yet revised the model, so you can&rsquo;t yet know how to revise your tests for the model. You will, therefore, revise the model tests after revising the model, just as you created the original model tests after implementing the reactive model.

## <a name="addjest"></a>Add Jest test

1. You already have Jest tests for the search-form component in that component&rsquo;s directory. Now you will add Jest tests for the detail component. But it doesn&rsquo;t yet exist. So create a component for the detail view (`npm run ng generate component detail`). The new component will be located in a `detail` directory inside the `app` directory. It will include a `spec.ts` file with one test. However, Jest in watch mode will not notice the addition of that file. To include that file in Jest tests, quit Jest in your bash shell (`CTL`-`c`) and relaunch it (`npm run watch:unit`). The branch should pass the new test.
1. As you saw in Lesson 10, a new Angular component by default implements the ngOnInit() &ldquo;lifecycle hook&rdquo; method. This component will not require that. So, as you did in Lesson 10, delete `implements OnInit`, the `ngOnInit()` function declaration, and the importation of `OnInit`. This should not change the test results.
1. The new component contains an empty constructor. Empty constructors violate one of the currently configured rules of ESLint, so delete the constructor.
1. Some of your Jest tests are in the `src/app/app.component.spec.ts` file. Just as in Lesson 10, when those tests encounter the `detail` element in the template, they need to interpolate that component. To make that happen, add two things to the file, as you did in Lesson 10:
   1. under the `SearchFormComponent` import statement, a similar import statement for the detail component
   1. in the argument to `TestBed.configureTestingModule()`, a third element in the array value of the `declarations` property: `DetailComponent`
1. In the callback argument to the `describe()` function in `detail.component.spec.ts`, add a declaration for the variable `compiled`, as in `search-form.component.spec.ts`.
1. In the argument to the `beforeEach()` function, after the initialization of `component` add the same initialization of `compiled` as in `search-form.component.spec.ts`.

1. The content in the detail view will depend almost entirely on the user&rsquo;s choice to follow one of the links in the home view. Performing an action in one view and checking the effects in another view is testable with Cypress, not Jest. But the detail view will always contain a link taking the user back to the home view, with `"/"` as a relative URL. Add this Jest test to `detail.component.spec.ts`, requiring that link to exist and to say &ldquo;Home&rdquo;:

   ```typescript
   it('should contain a link to the home view', () => {
     const homeLink = compiled.querySelector('a[href="/"]');
     expect(homeLink && homeLink.textContent).toBe('Home');
   });
   ```

   The branch should fail this test.

## <a name="revisecypress"></a>Revise Cypress tests

1. The existing Cypress tests in the search-results group use the function `checkNames()`. It defines a `shownNames` constant, an array of the names shown in the search result. Now those names will be contained by `a` elements, links, children of `li` elements, rather than being directly contained by `li` elements. Strengthen the tests in that group by revising the `checkNames()` function. Redefine `shownNames` to require that the names be links. Change the selector argument of `find()` from `'li'` to `'li > a'`. For understandability, also change the name of the argument of the `map()` method from `li` to `a`. The new selector should make the branch begin to fail both Cypress tests in the search-results group, since the names are not yet links.

## <a name="addcypress"></a>Add Cypress tests

One group of Cypress tests deals with the styles of focusable and hoverable elements. It contains a variable (`styles`) and three functions supporting its tests. The group for search-result tests has not needed that support, because search results have been plain text, which can&rsquo;t be put into focus and don&rsquo;t respond when hovered over. But now search results will contain links, and links **can** be focused and **do** respond when hovered over. So you will need to add Cypress tests to the search-results group that operate the search form, produce search results, and then manipulate the focus and/or hover states of links, to ensure that link styles respond as expected. Therefore, new tests in this group will need access to the support that is now confined to the focus-and-hover group.

1. To make the `styles` variable and the functions in the focus-and-hover group available to tests in the search-results group, move that variable and those functions to the top of the top-level group, `'home view'`, before the call to `beforeEach()`.
1. The `styles` variable specifies expected focus and hover styles. Focus styles are uniform across element types, so the existing `focus` and `blur` properties can apply to links, too. But the `over` and `out` properties, describing hover styles, apply only to buttons and labels. Therefore, add `links` subproperties to them. An appropriate value for `styles.over.links` is:

   ```typescript
   link: {
     color: 'rgb(255, 255, 255)',
     'background-color': 'rgb(0, 116, 201)',
     'text-decoration': 'underline'
   }
   ```

   It specifies underlined white text on a Utopia Link Blue background.

   Add a similar `link` property to the value of `styles.out`, but specify Utopia Link Blue as the text color and white as the background color.

1. Add a test to the search-result group to require shown results to be unambiguous. Unambiguous results will need to show more than names, since multiple persons can have identical names. To make the results unambiguous, require that they have this format: `Familyname,Givenname (01234)`. You can do this by adding this test:

   ```typescript
   it('should show unambiguous results', () => {
     setQuery('Buckley');
     submitForm();
     cy.get('form + section[role=status] > ul')
       .first()
       .then($ul => {
         const shownResults = Array.from($ul.find('li > a')).map(
           a => a.textContent
         );
         expect(
           shownResults.every(shownResult => /^.+ \(\d{6}\)/.test(shownResult))
         ).equal(true);
       });
   });
   ```

   You may change `'Buckley'` (in this test and the following tests) to any other substring that will match at least one name.

1. Add a test to the group to ensure that activating a person link changes the view title to that of the detail view. The test will define what the title should be. Make it &ldquo;Person Detail: Utopia Crew Search&rdquo;. This test will require that:

   ```typescript
   it('detail title should be Person Detail: Utopia Crew Search ', () => {
     setQuery('Buckley');
     submitForm();
     cy.get('form + section[role=status] > ul > li > a')
       .first()
       .then($ul => {
         $ul.click();
         getTitle().should('equal', 'Person Detail: Utopia Crew Search');
       });
   });
   ```

   The branch should fail this test.
1. Add a test to the group requiring the detail view to contain a description list (an HTML list of attributes and values, using `dl`, `dt`, and `dd` elements) filled with information about a particular person. At the minimum, whatever the attributes and values might be, the name of the person should be part of the text content of the description list. This test will check whether the branch satisfies this requirement:

   ```typescript
   it('detail should include name of person selected after search', () => {
     setQuery('Buckley');
     submitForm();
     cy.get('form + section[role=status] > ul > li > a')
       .first()
       .then($ul => {
         $ul.click();
         const list = cy.get('dl');
         list.should('contain', 'Buckley');
       });
   });
   ```

   The branch should fail this test.
1. Routing uses the URL to determine the view. The link of a person with ID 012345 will have `'/detail/012345'` as its destination. A user should be able to get to that person&rsquo; detail view either by searching in the home view and activating the person&rsquo;s link or by directly visiting that URL. On that basis, create this Cypress test group and test, after (not inside) the home-view group:

   ```typescript
   describe('detail view',() => {
     it('should include name of person requested', () => {
       cy.visit('/detail/004852');
       const list = cy.get('dl');
       list.should('contain', 'Buckley');
     });
   });
   ```

   (As stated above, you may change the person.) The branch should fail this test.

## <a name="revise"></a>Revise, pass

1. Enable the use of the Crewfinder API. The Crewfinder API, implementing the [CORS standard](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS), permits queries only from inside the `Utopia.com` network. In the `angular.json` file, you previously changed the value of the `projects.crewinfo-angular.architect.serve.options.host` property from `"localhost.Utopia.com"` to `"localhost"` so that you could develop and test your application even when not connected to the Utopia (or any) network. But the API will reject queries from `localhost`. So use your code editor to restore the original value of the `host` property.

## <a name="create"></a>Create service

1. In your bash shell, create a `crewfinder` service within a `crewfinder` directory in the `app` directory (`npm run ng generate service crewfinder/crewfinder`). This command should create an `app/crewfinder` directory, containing:
   - a `crewfinder.service.ts` file, which:
     - imports the `Injectable` class
     - defines a `CrewfinderService` class with an empty constructor
   - a `crewfinder.service.spec.ts` file with a test
1. The `crewfinder` service will connect to Utopia&rsquo;s Crewfinder REST API to get data. It will use the HTTP protocol for this connection, like a web browser. To give the module access to the HTTP protocol, in `app.module.ts`:
   1. Add a statement importing `HttpClientModule` from `'@angular/common/http'`.
   1. Add `HttpClientModule` to the array value of the `imports` property of the argument to the `@NgModule` decorator.
1. To give the `CrewfinderService` class access to the `get()` method of the `HttpClient` class:
   1. Add to the `crewfinder.service.ts` file a statement importing `HttpClient` from `'@angular/common/http'`.
   1. Add the argument `private http: HttpClient` to the constructor of the `CrewfinderService` class.
1. To give Jest access to the `HttpClientModule`, add to `crewfinder.service.spec.ts`:
   1. a statement importing `HttpClientModule` from `'@angular/common/http'`
   1. the property `imports: [HttpClientModule]` in the object argument of the `TestBed.configureTestingModule()` method
1. Add a member to that class identifying the URL hosting internal Utopia APIs: `apiURL = 'https://apii.cf.opsp.c1.Utopia.com';`.
1. Add a similar member identifying the remainder of the URL for the Crewfinder API: `crewfinderURL = 'rs/cf/crewfinder-webservice/public/people';`.
1. Add to the `CrewfinderService` class this function retrieving the records of crew members whose family names begin with a specified string:

   ```typescript
   getRecordsByNameStart: (n: string) => Observable<Record<string, any>> =
     nameStart => this.http.get(
       `${this.apiURL}/${this.crewfinderURL}?lastName=${nameStart}`
     );
   ```

   The `get()` method returns an Observable. A calling function can subscribe to it. When the response has been received, the subscriber will act on the data.

## <a name="use"></a>Use service

1. In `search-form.component.ts`, add a statement importing `CrewfinderService` from `'../crewfinder/crewfinder.service'`.
1. Make an instance of the `CrewfinderService` class available to the `SearchFormComponent` constructor by inserting a `private crewfinderService: CrewfinderService` argument into the currently empty argument list.
1. Your Jest tests now assume that the `SearchFormComponent` class has a `names` member. Initialize that member before `matchingNames` with the statement:

   ```typescript
   names: string[] = [];
   ```

1. That member replaces the `names` array imported from the `names.ts` file, so remove the import statement for `names`.
1. After `modeNameOf()` define this function, **recursively** fetching the records from a specified letter to Z and then calling a function:

   ```typescript
   getRemainingNames: (s: number, e: number, c: () => void) => void = (
     startCharCode,
     endCharCode,
     callback
   ) => {
     this.crewfinderService
       .getRecordsByNameStart(String.fromCharCode(startCharCode))
       .subscribe(data => {
         this.names.push(
           ...data.map(record => {
             const name: string = record[`preferredName`].nameLastFirst;
             return name.replace(', ', ',');
           })
         );
         if (startCharCode < endCharCode) {
           this.getRemainingNames(++startCharCode, endCharCode, callback);
         } else {
           this.names.sort();
           callback();
         }
       });
   };
   ```

   This function requires two numbers and a function as arguments. The two numbers are character codes. It calls the `getRecordsByNameStart()` method of the `CrewfinderService` class on the first number&rsquo;s character, using the `String.fromCharCode()` method to get that character. By subscribing, it waits for the Observable result. That result is an array of objects, one object per crew member. For each object, it finds the `preferredName.nameLastFirst` property. It reformats that name by deleting the space after the comma, conforming it to the format used in this application. Then it pushes all of the names in the batch onto the `names` array.

   After processing the batch, it determines whether it is the last batch to be processed. If not (i.e. if the character code is less than the last character code), it executes itself again, after incrementing the character code by 1. If this **was** the last batch, it finishes by sorting the `names` array alphabetically and then calling the callback function that was specified as the third argument.

   In this way, the function ensures that the callback function will wait for all the names to be retrieved and added to the `names` array, before being executed.

1. Define this function to populate the `names` array with all the names from `a` to `z`:

   ```typescript
   getAndUseNames: (c: () => void) => void = callback => {
     const startCharCode = 65;
     const endCharCode = 90;
     this.getRemainingNames(startCharCode, endCharCode, callback);
   };
   ```

1. Revise the `handleInputChange()` function to make use of `getAndUseNames()`:

   1. Where `names` appears, change it to `this.names`, since `names` is now a class member.
   1. Replace the two calls to `populateMatchingNames()` and `populateSummary()` with this code:

      ```typescript
      if (this.names.length) {
        populateMatchingNames();
        populateSummary();
      } else {
        this.getAndUseNames(() => {
          populateMatchingNames();
          populateSummary();
        });
      }
      ```

      This code calls these two functions, as before, if the `names` array already has content. Otherwise, however, it calls the `getAndUseNames()` function to populate the `names` array. When that operation has ended, the `getAndUseNames()` function will call its callback function, which will call the two functions, ensuring that the names are complete before they are used.

      When a Jest test prepopulates the `names` array, it makes `handleInputChange()` use the mock names and not fetch names from the Crewfinder service.

      This change should make the branch once again pass all the Jest tests.

1. The branch should fail some of your revised last Cypress test, because some results should fall outside the specified ranges. Inspect the Cypress Command Log to find the actual counts. Revise the ranges to enclose the actual results, allowing a reasonable margin for future changes in crew size and names. After that, the branch should pass all the tests.

1. The application no longer gets its names from the `src/assets/names.ts` file, so that file is now obsolete. Remove it.

## <a name="completion"></a>Completion

You have now made your application use real data to provide search results to users. Until now all interactions have taken place in a single view.

In the next lesson you will add a second view to the application. The list of matching names will become a list of links. Activating a link will take the user to a new view, containing detailed information about the crew member named by that link.

1. Open the `README-switch.md` file and follow the &ldquo;Completion&rdquo; instructions.

==> tdd-lab.npm/lessons/12/README-old.md <==
# tdd-lab

Building Robust User Interfaces: A Laboratory Course in Test-Driven Accessible Angular Development

## Lesson 12: Routing

### Prerequisites

Completion of [Lesson 11](https://bitbucket.Utopia.com:8443/users/uqxq/repos/ui-bootcamp/browse?at=refs%2Fheads%2Ffeature%2FXXX-000-lesson-11).

### Summary

Offering two views on two routes.

### Introduction

This is Lesson 12 of &ldquo;Building Robust UIs&rdquo;.

In Lesson 11 you replaced sample data with real data from a service and revised your Cypress tests to accommodate variability in results and allow time for results to arrive.

When users search with your application, they currently get only names. But the Utopia Crewfinder service provides more than names. In this lesson you will make your application provide additional data about selected persons. To do this, you will change the result in the home view, converting a list of names to a list of person links. When a user activates one of the links, the application will switch to another view, where details about the selected person will be displayed. In this detail view, there will also be a link bringing the user back to the home view.

The plan for this lesson is:

1. revise Jest tests
1. add Jest test for a new detail component
1. revise Cypress tests
1. revise the implementation to include the new feature
1. ensure that the branch passes all the tests
1. revise Jest tests on the search-form model???
1. add Jest tests on the detail model

### Instructions

#### Setup

1. Open the `README-setup.md` file and follow the &ldquo;Setup&rdquo; instructions.

#### Revise Jest test

##### Root-component test

1.  One of your tests in `app.component.spec.ts` requires the `main` element to have `crewinfo-search-form` as a child element. That component has provided the only view in the application. Now, however, there will be two views. The Angular router will decide which view appears. The standard mechanism for that choice is a `router-outlet` component. Therefore, revise that test so the expected child is a `router-outlet` element. The branch should fail the revised test.

##### Search-form-component tests

Your tests in `search-form.component.spec.ts` are of two kinds:

- tests of the view before any search result
- tests of the model

The pre-result view tests should all be viable, without change, after you introduce a second view. The result will become links, but those tests don&rsquo;t deal with the result. Nothing else in the search-form view will change.

On the other hand, you will need to revise the tests of the model, because the model will now handle details, not only names, of persons. But you have not yet revised the model, so you can&rsquo;t yet know how to revise your tests for the model. You will, therefore, revise the model tests after revising the model, just as you created the original model tests after implementing the reactive model.

#### Prepare to add Jest test

1. You already have Jest tests for the search-form component in that component&rsquo;s directory. Now you will add Jest tests for the detail component. But it doesn&rsquo;t yet exist. So create a component for the detail view (`npm run ng generate component detail`). The new component will be located in a `detail` directory inside the `app` directory. It will include a `spec.ts` file with one test. However, Jest in watch mode will not notice the addition of that file. To include that file in Jest tests, quit Jest in your bash shell (`CTL`-`c`) and relaunch it (`npm run watch:unit`). The branch should pass the new test.
1. As you saw in Lesson 10, a new Angular component by default implements the ngOnInit() &ldquo;lifecycle hook&rdquo; method. This component will not require that. So, as you did in Lesson 10, delete `implements OnInit`, the `ngOnInit()` function declaration, and the importation of `OnInit`. This should not change the test results.
1. The new component contains an empty constructor. Empty constructors violate one of the currently configured rules of ESLint, so delete the constructor.
1. Some of your Jest tests are in the `src/app/app.component.spec.ts` file. Just as in Lesson 10, when those tests encounter the `detail` element in the template, they need to interpolate that component. To make that happen, add two things to the file, as you did in Lesson 10:
   1. under the `SearchFormComponent` import statement, a similar import statement for the detail component
   1. in the argument to `TestBed.configureTestingModule()`, a third element in the array value of the `declarations` property: `DetailComponent`
1. In the callback argument to the `describe()` function in `detail.component.spec.ts`, add a declaration for the variable `compiled`, as in `search-form.component.spec.ts`.
1. In the argument to the `beforeEach()` function, after the initialization of `component` add the same initialization of `compiled` as in `search-form.component.spec.ts`.

#### Add Jest test

1. The content in the detail view will depend almost entirely on the user&rsquo;s choice to follow one of the links in the home view. Performing an action in one view and checking the effects in another view is testable with Cypress, not Jest. But the detail view will always contain a link taking the user back to the home view, with `"/"` as a relative URL. Add this Jest test to `detail.component.spec.ts`, requiring that link to exist and to say &ldquo;Home&rdquo;:
   ```typescript
   it('should contain a link to the home view', () => {
     const homeLink = compiled.querySelector('a[href="/"]');
     expect(homeLink && homeLink.textContent).toBe('Home');
   });
   ```
   The branch should fail this test.

#### Revise Cypress tests

1. The existing Cypress tests in the search-results group use the function `checkNames()`. It defines a `shownNames` constant, an array of the names shown in the search result. Now those names will be contained by `a` elements, links, children of `li` elements, rather than being directly contained by `li` elements. Strengthen the tests in that group by revising the `checkNames()` function. Redefine `shownNames` to require that the names be links. Change the selector argument of `find()` from `'li'` to `'li > a'`. For understandability, also change the name of the argument of the `map()` method from `li` to `a`. The new selector should make the branch begin to fail both Cypress tests in the search-results group, since the names are not yet links.

#### Prepare to add Cypress tests

One group of Cypress tests deals with the styles of focusable and hoverable elements. It contains a variable (`styles`) and three functions supporting its tests. The group for search-result tests has not needed that support, because search results have been plain text, which can&rsquo;t be put into focus and don&rsquo;t respond when hovered over. But now search results will contain links, and links **can** be focused and **do** respond when hovered over. So you will need to add Cypress tests to the search-results group that operate the search form, produce search results, and then manipulate the focus and/or hover states of links, to ensure that link styles respond as expected. Therefore, new tests in this group will need access to the support that is now confined to the focus-and-hover group.

1. To make the `styles` variable and the functions in the focus-and-hover group available to tests in the search-results group, move that variable and those functions to the top of the top-level group, `'home view'`, before the call to `beforeEach()`.
1. The `styles` variable specifies expected focus and hover styles. Focus styles are uniform across element types, so the existing `focus` and `blur` properties can apply to links, too. But the `over` and `out` properties, describing hover styles, apply only to buttons and labels. Therefore, add `links` subproperties to them. An appropriate value for `styles.over.links` is:

   ```typescript
   link: {
     color: 'rgb(255, 255, 255)',
     'background-color': 'rgb(0, 116, 201)',
     'text-decoration': 'underline'
   }
   ```

   It specifies underlined white text on a Utopia Link Blue background.

   Add a similar `link` property to the value of `styles.out`, but specify Utopia Link Blue as the text color and white as the background color.

#### Add Cypress tests

1. Add a test to the search-results group to require shown results to be unambiguous. Unambiguous results will need to show more than names, since multiple persons can have identical names. To make the results unambiguous, require that they have this format: `Familyname,Givenname (01234)`. You can do this by adding this test:

   ```typescript
   it('should show unambiguous results', () => {
     setQuery('Buckley');
     submitForm();
     cy.get('form + section[role=status] > ul')
       .first()
       .then($ul => {
         const shownResults = Array.from($ul.find('li > a')).map(
           a => a.textContent
         );
         expect(
           shownResults.every(shownResult => /^.+ \(\d{6}\)/.test(shownResult))
         ).equal(true);
       });
   });
   ```

   You may change `'Buckley'` (in this test and the following tests) to any other substring that will match at least one name.

1. Add a test to ensure that activating a person link changes the view title to that of the detail view. The test will define what the title should be. Make it &ldquo;Person Detail: Utopia Crew Search&rdquo;. This test will require that:
   ```typescript
   it('detail title should be Person Detail: Utopia Crew Search ', () => {
     setQuery('Buckley');
     submitForm();
     cy.get('form + section[role=status] > ul > li > a')
       .first()
       .then($ul => {
         $ul.click();
         getTitle().should('equal', 'Person Detail: Utopia Crew Search');
       });
   });
   ```
1. Add a test requiring the detail view to provide information about the person whose link the user has activated. At the minimum, whatever the attributes and values in the detail view might be, the name of the person should be part of the text content of the description list. This test will check whether the branch satisfies this requirement:
   ```typescript
   it('detail should include name of person', () => {
     setQuery('Buckley');
     submitForm();
     cy.get('form + section[role=status] > ul > li > a')
       .first()
       .then($ul => {
         $ul.click();
         const list = cy.get('dl');
         list.should('contain', 'Buckley');
       });
   });
   ```

#### Prepare to add Cypress tests

1. In `e2e/src/integration/app.spec.ts`, copy the home-view group to create a new group for the detail view. Change its description accordingly.
1. Assume that the relative URL for the detail view of the person whose ID is 1234 is `/detail/1234`. On that basis, in the detail group revise the `beforeEach()` argument&rsquo;s `cy.visit()` argument. You can use the ID of anybody at Utopia that you wish to use.
1. The three subgroups of the home-view group will not apply to the detail-view group, so delete them from the detail-view group. That should leave one test in the detail-view group.

#### Add Cypress tests

1. Assume that the browser title of the detail view is &ldquo;Detail: Utopia Crew Search&rdquo;. On that basis, revise the test. The branch should fail this test.
1. The detail view will also contain information about a person. A standard structure for such information is a _description list_, containing attributes (such as &ldquo;Job title&rdquo;) and values (such as &ldquo;Developer II&rdquo;). The elements comprising such a list are `dl` (list), `dt` (attribute), and `dd` (value). Add this test requiring such a list to exist, with at least one attribute followed by a value:
   ```typescript
   it('should contain a description list', () => {
     const descriptionList = compiled.querySelector('dl > dt dd');
     expect(descriptionList).toBeTruthy();
   });
   ```
   This test requires a `dl` element with at least two child elements: a `dt` immediately followed by a `dd`. The branch should fail this test.
1. Add a test requiring a `dl` element containing a string that should appear in the description list for the person that you selected. An example of this is:
   ```typescript
   it('should contain information about a specified person', () => {
     const list = compiled.querySelector('dl');
     expect(list && list.textContent).toContain('Quarry Ridge');
   });
   ```
   The branch should fail this test.

##### Configure model

You could implement this change with either of the following strategies:

1. Store all the details when the application first retrieves data from the service, and display the selected details on request.
1. Store only the names until details on a particular person are requested, and then get the details on that person from the Crewfinder service.

Strategy 1 would minimize the latency between requests for details and the display of details. Strategy 2 would minimize the memory required by the application.

As you learned in Lesson 11, the Crewfinder service does not offer an option to retrieve only names. If you want all the names but only the names, you must still retrieve all the details about everybody. In Lesson 11, you discarded all the details except the names, because you needed only the names.

In this case, Strategy 1 seems better, because:

- Your application necessarily gets all the details from the Crewfinder service, and given the principle of prioritizing the experience of the user, Strategy 1 seems more reasonable than Strategy 2. So, in this lesson, you will implement the revisions according to Strategy 1.

1. Both of your components have `component.ts` files where their models are defined. A new Angular component by default implements the `ngOnInit()` &ldquo;lifecycle hook&rdquo; method. This component will not require that. So delete `implements OnInit`, the `ngOnInit()` function declaration, and the importation of `OnInit`. This should not change the test results.
1. You will move form-related content from the `app.component.ts` to the `search-form.component.ts` file. Start with the `names` import statement. Its destination file is embedded one level deeper in the filesystem, so change the relative URL to start with `../../` instead of `../`.
1. Almost all of the members of the `AppComponent` class relate to the form. The only exception is the `title` variable. So move all the rest into the `SearchFormComponent` class.

#### Revise search-form model tests

will get the names of crew members from an `assets/names.ts` file. You can no longer assume this. The application will generally get the names from the Crewfinder API. But tests should also be able to _mock_ the API, i.e. to operate on a fixed sample of names, as they have up to now, so you can safely predict the correct behavior.

1. In `search-form.component.spec.ts`, there are three import statements. Add one importing `HttpClientModule` from `'@angular/common/http'`. This will permit your Jest tests to compile the search-form component when it begins to use HTTP to obtain names.
1. Add `HttpClientModule` to the array value of the `imports` property of the argument to `TestBed.configureTestingModule()`.
1. In the model group&rsquo;s callback argument, after the definition of `setFormValue()`, add this constant definition, filling in the names from the `names.ts` file:
   ```typescript
   const names = ['Xerri,Natalie', '...', 'Xuereb,Paul'];
   ```
1. Before the first test in the model group, add this statement:
   ```typescript
   beforeEach(() => {
     component.names = names;
   });
   ```
   This statement assumes that the `SearchFormComponent` class will have a `names` member containing a complete array of the names. By setting its value to the array of 19 sample names, this statement will let you test the model with that sample.

The `SearchFormComponent` has member variables named `names`, `matchingNames`, and `resultNames`. Each is an array of strings. That has been enough until now. In this lesson the component will display person links that distinguish among persons with identical names. It will also keep previously discarded details about persons. So these three members and the tests for them will need to change.

1. In `search-form.component.spec.ts`, replace the `names` array with:
   ```typescript
   const persons = {
     12345: {
       name: 'Waysofworking,New',
       mailstop: 'ab12'
     },
     23456: {
       name: 'Jeans,Casual',
       mailstop: 'cd34'
     },
     34567: {
       name: 'Station,Paoli',
       mailstop: 'ef56'
     }
   };
   ```
2. In the `beforeEach()` function of the model group, replace `names` with `persons`.
3. In the test for the initial value of `resultNames`, replace `resultNames` with `resultPersons` and eplace the `resultNames` array constant with:
   ```typescript
   const resultPersons: object = {};
   ```

#### Reconfigure

1. Enable the use of the Crewfinder API. The Crewfinder API, implementing the [CORS standard](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS), permits queries only from inside the `Utopia.com` network. In the `angular.json` file, you previously changed the value of the `projects.crewinfo-angular.architect.serve.options.host` property from `"localhost.Utopia.com"` to `"localhost"` so that you could develop and test your application even when not connected to the Utopia (or any) network. But the API will reject queries from `localhost`. So use your code editor to restore the original value of the `host` property.

#### Create service

1. In your bash shell, create a `crewfinder` service within a `crewfinder` directory in the `app` directory (`npm run ng generate service crewfinder/crewfinder`). This command should create an `app/crewfinder` directory, containing:
   - a `crewfinder.service.ts` file, which:
     - imports the `Injectable` class
     - defines a `CrewfinderService` class with an empty constructor
   - a `crewfinder.service.spec.ts` file with a test
1. The `crewfinder` service will connect to Utopia&rsquo;s Crewfinder REST API to get data. It will use the HTTP protocol for this connection, like a web browser. To give the module access to the HTTP protocol, in `app.module.ts`:
   1. Add a statement importing `HttpClientModule` from `'@angular/common/http'`.
   1. Add `HttpClientModule` to the array value of the `imports` property of the argument to the `@NgModule` decorator.
1. To give the `CrewfinderService` class access to the `get()` method of the `HttpClient` class:
   1. Add to the `crewfinder.service.ts` file a statement importing `HttpClient` from `'@angular/common/http'`.
   1. Add the argument `private http: HttpClient` to the constructor of the `CrewfinderService` class.
1. To give Jest access to the `HttpClientModule`, add to `crewfinder.service.spec.ts`:
   1. a statement importing `HttpClientModule` from `'@angular/common/http'`
   1. the property `imports: [HttpClientModule]` in the object argument of the `TestBed.configureTestingModule()` method
1. Add a member to that class identifying the URL hosting internal Utopia APIs: `apiURL = 'https://apii.cf.opsp.c1.Utopia.com';`.
1. Add a similar member identifying the remainder of the URL for the Crewfinder API: `crewfinderURL = 'rs/cf/crewfinder-webservice/public/people';`.
1. Add to the `CrewfinderService` class this function retrieving the records of crew members whose family names begin with a specified string:
   ```typescript
   getRecordsByNameStart: (n: string) => Observable<Record<string, any>> =
     nameStart => this.http.get(
       `${this.apiURL}/${this.crewfinderURL}?lastName=${nameStart}`
     );
   ```
   The `get()` method returns an Observable. A calling function can subscribe to it. When the response has been received, the subscriber will act on the data.

#### Use service

1. In `search-form.component.ts`, add a statement importing `CrewfinderService` from `'../crewfinder/crewfinder.service'`.
1. Make an instance of the `CrewfinderService` class available to the `SearchFormComponent` constructor by inserting a `private crewfinderService: CrewfinderService` argument into the currently empty argument list.
1. Your Jest tests now assume that the `SearchFormComponent` class has a `names` member. Initialize that member before `matchingNames` with the statement:
   ```typescript
   names: string[] = [];
   ```
1. That member replaces the `names` array imported from the `names.ts` file, so remove the import statement for `names`.
1. After `modeNameOf()` define this function, **recursively** fetching the records from a specified letter to Z and then calling a function:

   ```typescript
   getRemainingNames: (s: number, e: number, c: () => void) => void = (
     startCharCode,
     endCharCode,
     callback
   ) => {
     this.crewfinderService
       .getRecordsByNameStart(String.fromCharCode(startCharCode))
       .subscribe(data => {
         this.names.push(
           ...data.map(record => {
             const name: string = record[`preferredName`].nameLastFirst;
             return name.replace(', ', ',');
           })
         );
         if (startCharCode < endCharCode) {
           this.getRemainingNames(++startCharCode, endCharCode, callback);
         } else {
           this.names.sort();
           callback();
         }
       });
   };
   ```

   This function requires two numbers and a function as arguments. The two numbers are character codes. It calls the `getRecordsByNameStart()` method of the `CrewfinderService` class on the first number&rsquo;s character, using the `String.fromCharCode()` method to get that character. By subscribing, it waits for the Observable result. That result is an array of objects, one object per crew member. For each object, it finds the `preferredName.nameLastFirst` property. It reformats that name by deleting the space after the comma, conforming it to the format used in this application. Then it pushes all of the names in the batch onto the `names` array.

   After processing the batch, it determines whether it is the last batch to be processed. If not (i.e. if the character code is less than the last character code), it executes itself again, after incrementing the character code by 1. If this **was** the last batch, it finishes by sorting the `names` array alphabetically and then calling the callback function that was specified as the third argument.

   In this way, the function ensures that the callback function will wait for all the names to be retrieved and added to the `names` array, before being executed.

1. Define this function to populate the `names` array with all the names from `a` to `z`:
   ```typescript
   getAndUseNames: (c: () => void) => void = callback => {
     const startCharCode = 65;
     const endCharCode = 90;
     this.getRemainingNames(startCharCode, endCharCode, callback);
   };
   ```
1. Revise the `handleInputChange()` function to make use of `getAndUseNames()`:

   1. Where `names` appears, change it to `this.names`, since `names` is now a class member.
   1. Replace the two calls to `populateMatchingNames()` and `populateSummary()` with this code:

      ```typescript
      if (this.names.length) {
        populateMatchingNames();
        populateSummary();
      } else {
        this.getAndUseNames(() => {
          populateMatchingNames();
          populateSummary();
        });
      }
      ```

      This code calls these two functions, as before, if the `names` array already has content. Otherwise, however, it calls the `getAndUseNames()` function to populate the `names` array. When that operation has ended, the `getAndUseNames()` function will call its callback function, which will call the two functions, ensuring that the names are complete before they are used.

      When a Jest test prepopulates the `names` array, it makes `handleInputChange()` use the mock names and not fetch names from the Crewfinder service.

      This change should make the branch once again pass all the Jest tests. It will fail your revised Cypress test if any results fall outside the specified ranges, until you revise the ranges to enclose the actual results.

1. The application no longer gets its names from the `src/assets/names.ts` file, so that file is now obsolete. Remove it.

#### Completion

You have now made your application use real data to provide search results to users. Until now all interactions have taken place in a single view.

In the next lesson you will add a second view to the application. The list of matching names will become a list of links. Activating a link will take the user to a new view, containing detailed information about the crew member named by that link.

1. Open the `README-setup.md` file and follow the &ldquo;Completion&rdquo; instructions.
